name: Build, Test, and Deploy (Vercel + Hetzner)

on:
  push:
    branches: [ dev, main-hetz, 'feat/**', 'fix/**' ]
  repository_dispatch:
    types: [ deploy ]
  workflow_dispatch:

env:
  NODE_VERSION: 22

permissions:
  contents: read
  actions: read
  packages: write

concurrency:
  group: cicd-${{ github.event.repository.name || github.repository }}-${{ github.ref_name || github.event.client_payload.branch }}
  cancel-in-progress: true

jobs:
  detect:
    runs-on: ubuntu-latest
    outputs:
      repository:       ${{ steps.p.outputs.repository }}
      repository_name:  ${{ steps.p.outputs.repository_name }}
      branch:           ${{ steps.p.outputs.branch }}
      project_type:     ${{ steps.detect.outputs.PROJECT_TYPE }}
      slug:             ${{ steps.cfg.outputs.SLUG }}
      port:             ${{ steps.cfg.outputs.PORT }}
      domain_prod:      ${{ steps.dom.outputs.DOMAIN_PROD }}
      domain_admin:     ${{ steps.dom.outputs.DOMAIN_ADMIN }}
      domain_pgadmin:   ${{ steps.dom.outputs.DOMAIN_PGADMIN }}
    steps:
      - name: Extract payload (repo/branch)
        id: p
        run: |
          echo "repository=${{ github.event.client_payload.repository || github.repository }}" >> $GITHUB_OUTPUT
          echo "repository_name=${{ github.event.client_payload.repository_name || github.event.repository.name }}" >> $GITHUB_OUTPUT
          echo "branch=${{ github.event.client_payload.branch || github.ref_name }}" >> $GITHUB_OUTPUT

      - name: Checkout target website repo
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.p.outputs.repository }}
          ref: ${{ steps.p.outputs.branch }}
          fetch-depth: 0
          path: site

      - name: Verify package.json present
        working-directory: site
        run: test -f package.json || { echo "package.json not found in site/"; exit 1; }

      - name: Read .cicd-config.yml (slug/port/domains)
        id: cfg
        shell: bash
        working-directory: site
        run: |
          SLUG="site"
          PORT="3000"
          DOMAIN_PROD=""
          DOMAIN_ADMIN=""
          DOMAIN_PGADMIN=""
          if [ -f ".cicd-config.yml" ]; then
            get_val(){ grep -E "^$1:" .cicd-config.yml | head -1 | awk -F': *' '{print $2}' | tr -d "\"'"; }
            SLUG="$(get_val slug || echo "$SLUG")"
            PORT="$(get_val port || echo "$PORT")"
            DOM_BLOCK="$(awk '/^domains:/{f=1;next} f && /^[^ ]/{f=0} f{print}' .cicd-config.yml)"
            DOMAIN_PROD="$(printf '%s\n' "$DOM_BLOCK" | awk '/prod:/{print $2}' | tr -d "\"'")"
            DOMAIN_ADMIN="$(printf '%s\n' "$DOM_BLOCK" | awk '/admin:/{print $2}' | tr -d "\"'")"
            PGADMIN_SUB="$(get_val pgadmin_subdomain || true)"
            [ -n "$PGADMIN_SUB" ] && DOMAIN_PGADMIN="${PGADMIN_SUB}.${DOMAIN_PROD}"
          fi
          echo "SLUG=$SLUG" >> $GITHUB_OUTPUT
          echo "PORT=$PORT" >> $GITHUB_OUTPUT
          echo "DOMAIN_PROD_RAW=$DOMAIN_PROD" >> $GITHUB_OUTPUT
          echo "DOMAIN_ADMIN_RAW=$DOMAIN_ADMIN" >> $GITHUB_OUTPUT
          echo "DOMAIN_PGADMIN_RAW=$DOMAIN_PGADMIN" >> $GITHUB_OUTPUT

      - name: Detect project type
        id: detect
        working-directory: site
        run: |
          PT="node"
          if [ -f ".cicd-config.yml" ] && grep -qE '^project_type:\s*static' .cicd-config.yml; then
            PT="static"
          fi
          echo "PROJECT_TYPE=$PT" >> $GITHUB_OUTPUT

      - name: Finalize domains (default admin=admin.prod, pgadmin=dbui.prod)
        id: dom
        run: |
          PROD="${{ steps.cfg.outputs.DOMAIN_PROD_RAW }}"
          ADMIN="${{ steps.cfg.outputs.DOMAIN_ADMIN_RAW }}"
          PGADMIN="${{ steps.cfg.outputs.DOMAIN_PGADMIN_RAW }}"
          if [ -z "$PROD" ]; then
            echo "❌ DOMAIN_PROD missing (set it in .cicd-config.yml -> domains.prod)"; exit 1;
          fi
          if [ -z "$ADMIN" ]; then
            ADMIN="admin.${PROD}"
          fi
          if [ -z "$PGADMIN" ]; then
            PGADMIN="dbui.${PROD}"
          fi
          echo "DOMAIN_PROD=$PROD"    >> $GITHUB_OUTPUT
          echo "DOMAIN_ADMIN=$ADMIN"  >> $GITHUB_OUTPUT
          echo "DOMAIN_PGADMIN=$PGADMIN" >> $GITHUB_OUTPUT
          echo "Using domains: PROD=$PROD ADMIN=$ADMIN PGADMIN=$PGADMIN"

  build_test:
    runs-on: ubuntu-latest
    needs: [detect]
    steps:
      - uses: actions/checkout@v4
        with:
          repository: ${{ needs.detect.outputs.repository }}
          ref: ${{ needs.detect.outputs.branch }}
          path: site

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Clean npm lock (use Yarn only)
        working-directory: site
        run: rm -f package-lock.json

      - name: Install deps
        working-directory: site
        run: |
          if [ -f yarn.lock ]; then yarn install --immutable; \
          elif [ -f pnpm-lock.yaml ]; then corepack enable && pnpm i --frozen-lockfile; \
          else npm ci; fi

      - name: Lint (non-blocking)
        working-directory: site
        run: |
          if [ -f package.json ] && jq -e '.scripts.lint' package.json >/dev/null 2>&1; then \
            npm run lint || true; else echo "no lint script"; fi

      - name: Derive REPO_KEY (UPPERCASE, '-' -> '_')
        id: repokey
        run: |
          NAME="${{ needs.detect.outputs.repository_name }}"
          KEY_UPPER="$(echo "$NAME" | tr '[:lower:]-' '[:upper:]_')"
          echo "KEY_UPPER=$KEY_UPPER" >> $GITHUB_OUTPUT

      - name: Load SITE_ENV__{REPO_KEY} and normalize DB envs for this branch
        env:
          SITE_ENV: ${{ secrets[format('SITE_ENV__{0}', steps.repokey.outputs.KEY_UPPER)] }}
          BRANCH: ${{ needs.detect.outputs.branch }}
        working-directory: site
        run: |
          [ -n "${SITE_ENV:-}" ] || { echo "❌ Missing secret SITE_ENV__${{ steps.repokey.outputs.KEY_UPPER }}"; exit 1; }
          printf "%s\n" "$SITE_ENV" | sed 's/\r$//' > .env

          # If DATABASE_URL/DIRECT_DATABASE_URL are not present, derive from suffix based on branch
          have_db=$(grep -cE '^(DATABASE_URL|DIRECT_DATABASE_URL)=' .env || true)
          if [ "$have_db" -lt 2 ]; then
            if [ "$BRANCH" = "main-hetz" ]; then
              HDB="$(awk -F= '$1=="DATABASE_URL_HETZNER"{print $2}' .env | tail -1)"
              HDD="$(awk -F= '$1=="DIRECT_DATABASE_URL_HETZNER"{print $2}' .env | tail -1)"
              [ -n "$HDB" ] && echo "DATABASE_URL=$HDB" >> .env
              [ -n "$HDD" ] && echo "DIRECT_DATABASE_URL=$HDD" >> .env
            else
              VDB="$(awk -F= '$1=="DATABASE_URL_VERCEL"{print $2}' .env | tail -1)"
              VDD="$(awk -F= '$1=="DIRECT_DATABASE_URL_VERCEL"{print $2}' .env | tail -1)"
              [ -n "$VDB" ] && echo "DATABASE_URL=$VDB" >> .env
              # If no explicit direct URL, mirror DATABASE_URL
              if [ -n "$VDD" ]; then
                echo "DIRECT_DATABASE_URL=$VDD" >> .env
              else
                echo "DIRECT_DATABASE_URL=${VDB}" >> .env
              fi
            fi
          fi

          # Sanity check
          echo "DB envs in use:"
          grep -E '^(DATABASE_URL|DIRECT_DATABASE_URL)=' .env

          # Optional: warn if still missing
          grep -q '^DATABASE_URL=' .env || { echo "❌ DATABASE_URL still missing after normalization"; exit 1; }
          grep -q '^DIRECT_DATABASE_URL=' .env || { echo "❌ DIRECT_DATABASE_URL still missing after normalization"; exit 1; }

      - name: Prisma generate (for Next build)
        working-directory: site
        run: npx prisma generate

      - name: Build
        working-directory: site
        run: npm run build -- --no-lint

      - name: Unit tests (optional)
        working-directory: site
        run: npm test || echo "No tests / skipping"

      - name: (static only) assert out/
        if: needs.detect.outputs.project_type == 'static'
        working-directory: site
        run: test -d out || { echo "Static build missing out/"; exit 1; }

      - name: Upload out/ artifact (static only)
        if: needs.detect.outputs.project_type == 'static'
        uses: actions/upload-artifact@v4
        with:
          name: static-export
          path: site/out

  vercel_preview:
    needs: [detect, build_test]
    if: startsWith(needs.detect.outputs.branch, 'feat/') || startsWith(needs.detect.outputs.branch, 'fix/')
    runs-on: ubuntu-latest
    env:
      VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          repository: ${{ needs.detect.outputs.repository }}
          ref: ${{ needs.detect.outputs.branch }}
          path: site

      - name: Derive REPO_KEY (UPPERCASE, '-' -> '_')
        id: repokey
        run: |
          NAME="${{ needs.detect.outputs.repository_name }}"
          KEY_UPPER="$(echo "$NAME" | tr '[:lower:]-' '[:upper:]_')"
          echo "KEY_UPPER=$KEY_UPPER" >> $GITHUB_OUTPUT

      - name: Load SITE_ENV__{REPO_KEY} and export Vercel IDs
        env:
          SITE_ENV: ${{ secrets[format('SITE_ENV__{0}', steps.repokey.outputs.KEY_UPPER)] }}
        working-directory: site
        run: |
          [ -n "${SITE_ENV:-}" ] || { echo "❌ Missing secret SITE_ENV__${{ steps.repokey.outputs.KEY_UPPER }}"; exit 1; }
          printf "%s\n" "$SITE_ENV" | sed 's/\r$//' > .site_env
          ORG="$(awk -F= '/^VERCEL_ORG_ID=/{print $2}' .site_env | tail -1)"
          PRJ="$(awk -F= '/^VERCEL_PROJECT_ID=/{print $2}' .site_env | tail -1)"
          [ -n "$ORG" ] || ORG="$(awk -F= '/^orgId=/{print $2}' .site_env | tail -1)"
          [ -n "$PRJ" ] || PRJ="$(awk -F= '/^projectId=/{print $2}' .site_env | tail -1)"
          [ -n "$ORG" ] && echo "VERCEL_ORG_ID=$ORG" >> $GITHUB_ENV || { echo "❌ VERCEL_ORG_ID missing"; exit 1; }
          [ -n "$PRJ" ] && echo "VERCEL_PROJECT_ID=$PRJ" >> $GITHUB_ENV || { echo "❌ VERCEL_PROJECT_ID missing"; exit 1; }

      - if: env.VERCEL_TOKEN == ''
        run: echo "⚠️ Missing Vercel token; skipping Vercel preview." && echo "SKIP=1" >> $GITHUB_ENV

      - if: env.SKIP != '1'
        working-directory: site
        run: npm i -g vercel

      - if: env.SKIP != '1'
        working-directory: site
        run: vercel pull --yes --environment=preview --token="${{ env.VERCEL_TOKEN }}"

      - if: env.SKIP != '1'
        working-directory: site
        run: |
          : > .env
          if [ -f ".vercel/.env.preview.local" ]; then
            cat .vercel/.env.preview.local >> .env
          elif [ -f ".vercel/.env.development.local" ]; then
            cat .vercel/.env.development.local >> .env
          fi
          # Blend in SITE_ENV defaults (without overwriting)
          while IFS='=' read -r k v; do
            [ -z "$k" ] && continue
            [ "${k#\#}" != "$k" ] && continue
            if ! grep -qE "^${k}=" .env 2>/dev/null; then
              echo "${k}=${v}" >> .env
            fi
          done < .site_env
          echo "Preview .env (first lines):"; sed -n '1,20p' .env

      - name: Ensure DB vars (preview)
        if: env.SKIP != '1'
        working-directory: site
        run: |
          # Set DATABASE_URL if still missing
          if ! grep -q '^DATABASE_URL=' .env; then
            VDB="$(awk -F= '$1=="DATABASE_URL_VERCEL"{print $2}' .site_env | tail -1)"
            [ -n "$VDB" ] && echo "DATABASE_URL=$VDB" >> .env
          fi
          # Ensure DIRECT_DATABASE_URL always exists
          if ! grep -q '^DIRECT_DATABASE_URL=' .env; then
            DDB="$(awk -F= '$1=="DIRECT_DATABASE_URL_VERCEL"{print $2}' .site_env | tail -1)"
            if [ -n "$DDB" ]; then
              echo "DIRECT_DATABASE_URL=$DDB" >> .env
            else
              DB="$(awk -F= '$1=="DATABASE_URL"{print $2}' .env | tail -1)"
              echo "DIRECT_DATABASE_URL=$DB" >> .env
            fi
          fi
          echo "Using DB envs:"; grep -E '^(DATABASE_URL|DIRECT_DATABASE_URL)=' .env

      - if: env.SKIP != '1'
        working-directory: site
        run: npx prisma generate

      - if: env.SKIP != '1'
        working-directory: site
        run: vercel build --token="${{ env.VERCEL_TOKEN }}"

      - if: env.SKIP != '1'
        working-directory: site
        run: vercel deploy --prebuilt --token="${{ env.VERCEL_TOKEN }}"

  vercel_prod:
    needs: [detect, build_test]
    if: needs.detect.outputs.branch == 'dev'
    runs-on: ubuntu-latest
    env:
      VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          repository: ${{ needs.detect.outputs.repository }}
          ref: ${{ needs.detect.outputs.branch }}
          path: site

      - name: Derive REPO_KEY (UPPERCASE, '-' -> '_')
        id: repokey
        run: |
          NAME="${{ needs.detect.outputs.repository_name }}"
          KEY_UPPER="$(echo "$NAME" | tr '[:lower:]-' '[:upper:]_')"
          echo "KEY_UPPER=$KEY_UPPER" >> $GITHUB_OUTPUT

      - name: Load SITE_ENV__{REPO_KEY} and export Vercel IDs
        env:
          SITE_ENV: ${{ secrets[format('SITE_ENV__{0}', steps.repokey.outputs.KEY_UPPER)] }}
        working-directory: site
        run: |
          [ -n "${SITE_ENV:-}" ] || { echo "❌ Missing secret SITE_ENV__${{ steps.repokey.outputs.KEY_UPPER }}"; exit 1; }
          printf "%s\n" "$SITE_ENV" | sed 's/\r$//' > .site_env
          ORG="$(awk -F= '/^VERCEL_ORG_ID=/{print $2}' .site_env | tail -1)"
          PRJ="$(awk -F= '/^VERCEL_PROJECT_ID=/{print $2}' .site_env | tail -1)"
          [ -n "$ORG" ] || ORG="$(awk -F= '/^orgId=/{print $2}' .site_env | tail -1)"
          [ -n "$PRJ" ] || PRJ="$(awk -F= '/^projectId=/{print $2}' .site_env | tail -1)"
          [ -n "$ORG" ] && echo "VERCEL_ORG_ID=$ORG" >> $GITHUB_ENV || { echo "❌ VERCEL_ORG_ID missing"; exit 1; }
          [ -n "$PRJ" ] && echo "VERCEL_PROJECT_ID=$PRJ" >> $GITHUB_ENV || { echo "❌ VERCEL_PROJECT_ID missing"; exit 1; }

      - if: env.VERCEL_TOKEN == ''
        run: echo "⚠️ Missing Vercel token; skipping Vercel prod." && echo "SKIP=1" >> $GITHUB_ENV

      - if: env.SKIP != '1'
        working-directory: site
        run: npm i -g vercel

      - if: env.SKIP != '1'
        working-directory: site
        run: vercel pull --yes --environment=production --token="${{ env.VERCEL_TOKEN }}"

      - if: env.SKIP != '1'
        working-directory: site
        run: |
          : > .env
          if [ -f ".vercel/.env.production.local" ]; then
            cat .vercel/.env.production.local >> .env
          fi
          while IFS='=' read -r k v; do
            [ -z "$k" ] && continue
            [ "${k#\#}" != "$k" ] && continue
            if ! grep -qE "^${k}=" .env 2>/dev/null; then
              echo "${k}=${v}" >> .env
            fi
          done < .site_env
          echo "Prod .env (first lines):"; sed -n '1,20p' .env

      - name: Ensure DB vars (prod)
        if: env.SKIP != '1'
        working-directory: site
        run: |
          if ! grep -q '^DATABASE_URL=' .env; then
            VDB="$(awk -F= '$1=="DATABASE_URL_VERCEL"{print $2}' .site_env | tail -1)"
            [ -n "$VDB" ] && echo "DATABASE_URL=$VDB" >> .env
          fi
          if ! grep -q '^DIRECT_DATABASE_URL=' .env; then
            DDB="$(awk -F= '$1=="DIRECT_DATABASE_URL_VERCEL"{print $2}' .site_env | tail -1)"
            if [ -n "$DDB" ]; then
              echo "DIRECT_DATABASE_URL=$DDB" >> .env
            else
              DB="$(awk -F= '$1=="DATABASE_URL"{print $2}' .env | tail -1)"
              echo "DIRECT_DATABASE_URL=$DB" >> .env
            fi
          fi
          echo "Using DB envs:"; grep -E '^(DATABASE_URL|DIRECT_DATABASE_URL)=' .env

      - if: env.SKIP != '1'
        working-directory: site
        run: npx prisma generate

      - if: env.SKIP != '1'
        working-directory: site
        run: vercel build --prod --token="${{ env.VERCEL_TOKEN }}"

      - if: env.SKIP != '1'
        working-directory: site
        run: vercel deploy --prebuilt --prod --token="${{ env.VERCEL_TOKEN }}"

  # ---------------------------
  # Hetzner (unchanged logic)
  # ---------------------------
  image_build_push:
    needs: [detect, build_test]
    if: needs.detect.outputs.project_type == 'node' && needs.detect.outputs.branch == 'main-hetz'
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.meta.outputs.image }}
      ref:   ${{ steps.meta.outputs.ref }}
    steps:
      - uses: actions/checkout@v4
        with:
          repository: ${{ needs.detect.outputs.repository }}
          ref: ${{ needs.detect.outputs.branch }}
          path: site

      - name: Derive image coordinates
        id: meta
        run: |
          OWNER_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME="${{ needs.detect.outputs.repository_name }}"
          IMAGE="ghcr.io/${OWNER_LOWER}/${REPO_NAME}"
          SHORT="${GITHUB_SHA::7}"
          echo "image=$IMAGE" >> $GITHUB_OUTPUT
          echo "ref=$IMAGE:$SHORT" >> $GITHUB_OUTPUT

      - uses: docker/setup-buildx-action@v3

      - name: Derive REPO_KEY (UPPERCASE, '-' -> '_')
        id: repokey
        run: |
          NAME="${{ needs.detect.outputs.repository_name }}"
          KEY_UPPER="$(echo "$NAME" | tr '[:lower:]-' '[:upper:]_')"
          echo "KEY_UPPER=$KEY_UPPER" >> $GITHUB_OUTPUT

      - name: Export base URLs from SITE_ENV secret
        id: envparse
        env:
          SITE_ENV_SECRET: ${{ secrets[format('SITE_ENV__{0}', steps.repokey.outputs.KEY_UPPER)] }}
          DOMAIN: ${{ needs.detect.outputs.domain_prod }}
          ADMIN_DOMAIN: ${{ needs.detect.outputs.domain_admin }}
        run: |
          [ -n "${SITE_ENV_SECRET:-}" ] || { echo "❌ Missing SITE_ENV secret"; exit 1; }
          printf "%s\n" "$SITE_ENV_SECRET" | sed 's/\r$//' > .site_env
          get(){ awk -F= -v k="$1" '$1==k{print $2}' .site_env | tail -1; }
          NPU="$(get NEXT_PUBLIC_SITE_URL)";   [ -n "$NPU" ] || NPU="https://${DOMAIN}"
          NPA="$(get NEXT_PUBLIC_ADMIN_URL)";  [ -n "$NPA" ] || { [ -n "${ADMIN_DOMAIN:-}" ] && NPA="https://${ADMIN_DOMAIN}" || NPA=""; }
          SU="$(get SITE_URL)";                [ -n "$SU" ]  || SU="https://${DOMAIN}"
          echo "NEXT_PUBLIC_SITE_URL=$NPU"  >> $GITHUB_OUTPUT
          echo "NEXT_PUBLIC_ADMIN_URL=$NPA" >> $GITHUB_OUTPUT
          echo "SITE_URL=$SU"               >> $GITHUB_OUTPUT
          echo "Using base URLs:"; echo "$NPU"; echo "$NPA"; echo "$SU"

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build & push site image
        id: buildpush
        uses: docker/build-push-action@v6
        with:
          context: site
          push: true
          pull: true
          tags: |
            ${{ steps.meta.outputs.ref }}
            ${{ steps.meta.outputs.image }}:latest
          build-args: |
            NEXT_PUBLIC_SITE_URL=${{ steps.envparse.outputs.NEXT_PUBLIC_SITE_URL }}
            NEXT_PUBLIC_ADMIN_URL=${{ steps.envparse.outputs.NEXT_PUBLIC_ADMIN_URL }}
            SITE_URL=${{ steps.envparse.outputs.SITE_URL }}

  hetzner_node:
    needs: [detect, image_build_push]
    if: needs.detect.outputs.project_type == 'node' && needs.detect.outputs.branch == 'main-hetz'
    runs-on: ubuntu-latest
    steps:
      # (same as your current hetzner_node job – omitted here for brevity)
      # Keep your existing content unchanged
      - run: echo "Hetzner deploy steps unchanged; using your existing definitions."
