name: Build, Test, and Deploy (Vercel + Hetzner)

on:
  push:
    branches: [ dev, main-hetz, 'feat/**', 'fix/**' ]
  repository_dispatch:
    types: [ deploy ]
  workflow_dispatch:

env:
  NODE_VERSION: 22

permissions:
  contents: read
  actions: read
  packages: write

concurrency:
  group: cicd-${{ github.event.repository.name || github.repository }}-${{ github.ref_name || github.event.client_payload.branch }}
  cancel-in-progress: true

jobs:
  detect:
    runs-on: ubuntu-latest
    outputs:
      repository:       ${{ steps.p.outputs.repository }}
      repository_name:  ${{ steps.p.outputs.repository_name }}
      branch:           ${{ steps.p.outputs.branch }}
      project_type:     ${{ steps.detect.outputs.PROJECT_TYPE }}
      slug:             ${{ steps.cfg.outputs.SLUG }}
      port:             ${{ steps.cfg.outputs.PORT }}
      domain_prod:      ${{ steps.dom.outputs.DOMAIN_PROD }}
      domain_admin:     ${{ steps.dom.outputs.DOMAIN_ADMIN }}
      domain_pgadmin:   ${{ steps.dom.outputs.DOMAIN_PGADMIN }}
      db_mode:          ${{ steps.dbmode.outputs.DB_MODE }}
    steps:
      - name: Extract payload (repo/branch)
        id: p
        run: |
          echo "repository=${{ github.event.client_payload.repository || github.repository }}" >> $GITHUB_OUTPUT
          echo "repository_name=${{ github.event.client_payload.repository_name || github.event.repository.name }}" >> $GITHUB_OUTPUT
          echo "branch=${{ github.event.client_payload.branch || github.ref_name }}" >> $GITHUB_OUTPUT

      - name: Checkout target website repo
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.p.outputs.repository }}
          ref: ${{ steps.p.outputs.branch }}
          fetch-depth: 0
          path: site

      - name: Verify package.json present
        working-directory: site
        run: test -f package.json || { echo "package.json not found in site/"; exit 1; }

      - name: Read .cicd-config.yml (slug/port/domains)
        id: cfg
        shell: bash
        working-directory: site
        run: |
          SLUG="site"
          PORT="3000"
          DOMAIN_PROD=""
          DOMAIN_ADMIN=""
          DOMAIN_PGADMIN=""
          if [ -f ".cicd-config.yml" ]; then
            get_val(){ grep -E "^$1:" .cicd-config.yml | head -1 | awk -F': *' '{print $2}' | tr -d "\"'"; }
            SLUG="$(get_val slug || echo "$SLUG")"
            PORT="$(get_val port || echo "$PORT")"
            DOM_BLOCK="$(awk '/^domains:/{f=1;next} f && /^[^ ]/{f=0} f{print}' .cicd-config.yml)"
            DOMAIN_PROD="$(printf '%s\n' "$DOM_BLOCK" | awk '/prod:/{print $2}' | tr -d "\"'")"
            DOMAIN_ADMIN="$(printf '%s\n' "$DOM_BLOCK" | awk '/admin:/{print $2}' | tr -d "\"'")"
            PGADMIN_SUB="$(get_val pgadmin_subdomain || true)"
            [ -n "$PGADMIN_SUB" ] && DOMAIN_PGADMIN="${PGADMIN_SUB}.${DOMAIN_PROD}"
          fi
          echo "SLUG=$SLUG" >> $GITHUB_OUTPUT
          echo "PORT=$PORT" >> $GITHUB_OUTPUT
          echo "DOMAIN_PROD_RAW=$DOMAIN_PROD" >> $GITHUB_OUTPUT
          echo "DOMAIN_ADMIN_RAW=$DOMAIN_ADMIN" >> $GITHUB_OUTPUT
          echo "DOMAIN_PGADMIN_RAW=$DOMAIN_PGADMIN" >> $GITHUB_OUTPUT

      - name: Detect project type
        id: detect
        working-directory: site
        run: |
          PT="node"
          if [ -f ".cicd-config.yml" ] && grep -qE '^project_type:\s*static' .cicd-config.yml; then
            PT="static"
          fi
          echo "PROJECT_TYPE=$PT" >> $GITHUB_OUTPUT

      - name: Detect DB mode
        id: dbmode
        working-directory: site
        shell: bash
        run: |
          DBM="postgres"
          if [ -f ".cicd-config.yml" ] && grep -qiE '^db:\s*none' .cicd-config.yml; then
            DBM="none"
          fi
          echo "DB_MODE=$DBM" >> $GITHUB_OUTPUT
          echo "DB mode: $DBM"

      - name: Finalize domains (default admin=admin.prod, pgadmin=dbui.prod)
        id: dom
        run: |
          PROD="${{ steps.cfg.outputs.DOMAIN_PROD_RAW }}"
          ADMIN="${{ steps.cfg.outputs.DOMAIN_ADMIN_RAW }}"
          PGADMIN_RAW="${{ steps.cfg.outputs.DOMAIN_PGADMIN_RAW }}"
          if [ -z "$PROD" ]; then
            echo "‚ùå DOMAIN_PROD missing (set it in .cicd-config.yml -> domains.prod)"; exit 1;
          fi
          [ -n "$ADMIN" ] || ADMIN="admin.${PROD}"
          if [ "${{ steps.dbmode.outputs.DB_MODE }}" != "none" ]; then
            PGADMIN="${PGADMIN_RAW:-dbui.${PROD}}"
          else
            PGADMIN=""
          fi
          echo "DOMAIN_PROD=$PROD"    >> $GITHUB_OUTPUT
          echo "DOMAIN_ADMIN=$ADMIN"  >> $GITHUB_OUTPUT
          echo "DOMAIN_PGADMIN=$PGADMIN" >> $GITHUB_OUTPUT
          echo "Using domains: PROD=$PROD ADMIN=$ADMIN PGADMIN=${PGADMIN:-<disabled>}"


  build_test:
    runs-on: ubuntu-latest
    needs: [detect]
    steps:
      - uses: actions/checkout@v4
        with:
          repository: ${{ needs.detect.outputs.repository }}
          ref: ${{ needs.detect.outputs.branch }}
          path: site

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Clean npm lock (use Yarn only)
        working-directory: site
        run: rm -f package-lock.json

      - name: Install deps
        working-directory: site
        run: |
          if [ -f yarn.lock ]; then yarn install --immutable; \
          elif [ -f pnpm-lock.yaml ]; then corepack enable && pnpm i --frozen-lockfile; \
          else npm ci; fi

      - name: Lint (non-blocking)
        working-directory: site
        run: |
          if [ -f package.json ] && jq -e '.scripts.lint' package.json >/dev/null 2>&1; then \
            npm run lint || true; else echo "no lint script"; fi

      - name: Derive REPO_KEY (UPPERCASE, '-' -> '_')
        id: repokey
        run: |
          NAME="${{ needs.detect.outputs.repository_name }}"
          KEY_UPPER="$(echo "$NAME" | tr '[:lower:]-' '[:upper:]_')"
          echo "KEY_UPPER=$KEY_UPPER" >> $GITHUB_OUTPUT

      - name: Load SITE_ENV__{REPO_KEY} and normalize DB envs for this branch
        env:
          SITE_ENV: ${{ secrets[format('SITE_ENV__{0}', steps.repokey.outputs.KEY_UPPER)] }}
          BRANCH: ${{ needs.detect.outputs.branch }}
          DB_MODE: ${{ needs.detect.outputs.db_mode }}
        working-directory: site
        run: |
          [ -n "${SITE_ENV:-}" ] || { echo "‚ùå Missing secret SITE_ENV__${{ steps.repokey.outputs.KEY_UPPER }}"; exit 1; }
          printf "%s\n" "$SITE_ENV" | sed 's/\r$//' > .env

          if [ "$DB_MODE" != "none" ]; then
            # Always use Vercel DB for GitHub Action builds.
            # Hetzner DB is only used at runtime on the Hetzner server.
            VDB="$(awk -F= '$1=="DATABASE_URL_VERCEL"{print $2}' .env | tail -1)"
            VDD="$(awk -F= '$1=="DIRECT_DATABASE_URL_VERCEL"{print $2}' .env | tail -1)"
          
            if [ -z "$VDB" ]; then
              echo "‚ùå DATABASE_URL_VERCEL missing in .env"; exit 1;
            fi
          
            echo "DATABASE_URL=$VDB" >> .env
          
            if [ -n "$VDD" ]; then
              echo "DIRECT_DATABASE_URL=$VDD" >> .env
            else
              echo "DIRECT_DATABASE_URL=$VDB" >> .env
            fi
          
            echo "DB envs in use (Vercel for CI build):"
            grep -E '^(DATABASE_URL|DIRECT_DATABASE_URL)=' .env
          else
            echo "DB disabled (db: none) ‚Äî skipping DB env normalization/requirements."
          fi


      - name: Prisma generate (for Next build)
        working-directory: site
        run: |
          if [ -f prisma/schema.prisma ]; then
            npx prisma generate
          else
            echo "No Prisma schema found ‚Äî skipping generate"
          fi

      - name: Build
        working-directory: site
        run: npm run build

      - name: Unit tests (optional)
        working-directory: site
        run: npm test || echo "No tests / skipping"

      - name: (static only) assert out/
        if: needs.detect.outputs.project_type == 'static'
        working-directory: site
        run: test -d out || { echo "Static build missing out/"; exit 1; }

      - name: Upload out/ artifact (static only)
        if: needs.detect.outputs.project_type == 'static'
        uses: actions/upload-artifact@v4
        with:
          name: static-export
          path: site/out

  vercel_preview:
    needs: [detect, build_test]
    if: startsWith(needs.detect.outputs.branch, 'feat/') || startsWith(needs.detect.outputs.branch, 'fix/')
    runs-on: ubuntu-latest
    env:
      VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          repository: ${{ needs.detect.outputs.repository }}
          ref: ${{ needs.detect.outputs.branch }}
          path: site

      - name: Derive REPO_KEY (UPPERCASE, '-' -> '_')
        id: repokey
        run: |
          NAME="${{ needs.detect.outputs.repository_name }}"
          KEY_UPPER="$(echo "$NAME" | tr '[:lower:]-' '[:upper:]_')"
          echo "KEY_UPPER=$KEY_UPPER" >> $GITHUB_OUTPUT

      - name: Load SITE_ENV__{REPO_KEY} and export Vercel IDs
        env:
          SITE_ENV: ${{ secrets[format('SITE_ENV__{0}', steps.repokey.outputs.KEY_UPPER)] }}
        working-directory: site
        run: |
          [ -n "${SITE_ENV:-}" ] || { echo "‚ùå Missing secret SITE_ENV__${{ steps.repokey.outputs.KEY_UPPER }}"; exit 1; }
          printf "%s\n" "$SITE_ENV" | sed 's/\r$//' > .site_env
          ORG="$(awk -F= '/^VERCEL_ORG_ID=/{print $2}' .site_env | tail -1)"
          PRJ="$(awk -F= '/^VERCEL_PROJECT_ID=/{print $2}' .site_env | tail -1)"
          [ -n "$ORG" ] || ORG="$(awk -F= '/^orgId=/{print $2}' .site_env | tail -1)"
          [ -n "$PRJ" ] || PRJ="$(awk -F= '/^projectId=/{print $2}' .site_env | tail -1)"
          [ -n "$ORG" ] && echo "VERCEL_ORG_ID=$ORG" >> $GITHUB_ENV || { echo "‚ùå VERCEL_ORG_ID missing"; exit 1; }
          [ -n "$PRJ" ] && echo "VERCEL_PROJECT_ID=$PRJ" >> $GITHUB_ENV || { echo "‚ùå VERCEL_PROJECT_ID missing"; exit 1; }

      - if: env.VERCEL_TOKEN == ''
        run: echo "‚ö†Ô∏è Missing Vercel token; skipping Vercel preview." && echo "SKIP=1" >> $GITHUB_ENV

      - if: env.SKIP != '1'
        working-directory: site
        run: npm i -g vercel

      - if: env.SKIP != '1'
        working-directory: site
        run: vercel pull --yes --environment=preview --token="${{ env.VERCEL_TOKEN }}"

      - if: env.SKIP != '1'
        working-directory: site
        run: |
          : > .env
          if [ -f ".vercel/.env.preview.local" ]; then
            cat .vercel/.env.preview.local >> .env
          elif [ -f ".vercel/.env.development.local" ]; then
            cat .vercel/.env.development.local >> .env
          fi
          # Blend in SITE_ENV defaults (without overwriting)
          while IFS='=' read -r k v; do
            [ -z "$k" ] && continue
            [ "${k#\#}" != "$k" ] && continue
            if ! grep -qE "^${k}=" .env 2>/dev/null; then
              echo "${k}=${v}" >> .env
            fi
          done < .site_env
          echo "Preview .env (first lines):"; sed -n '1,20p' .env

      - name: Ensure DB vars (preview)
        if: env.SKIP != '1' && needs.detect.outputs.db_mode != 'none'
        working-directory: site
        run: |
          # Set DATABASE_URL if still missing
          if ! grep -q '^DATABASE_URL=' .env; then
            VDB="$(awk -F= '$1=="DATABASE_URL_VERCEL"{print $2}' .site_env | tail -1)"
            [ -n "$VDB" ] && echo "DATABASE_URL=$VDB" >> .env
          fi
          # Ensure DIRECT_DATABASE_URL always exists
          if ! grep -q '^DIRECT_DATABASE_URL=' .env; then
            DDB="$(awk -F= '$1=="DIRECT_DATABASE_URL_VERCEL"{print $2}' .site_env | tail -1)"
            if [ -n "$DDB" ]; then
              echo "DIRECT_DATABASE_URL=$DDB" >> .env
            else
              DB="$(awk -F= '$1=="DATABASE_URL"{print $2}' .env | tail -1)"
              echo "DIRECT_DATABASE_URL=$DB" >> .env
            fi
          fi
          echo "Using DB envs:"; grep -E '^(DATABASE_URL|DIRECT_DATABASE_URL)=' .env

      - if: env.SKIP != '1'
        name: Install deps (for Prisma + Vercel build)
        working-directory: site
        run: |
          if [ -f yarn.lock ]; then
            yarn install --immutable
          elif [ -f pnpm-lock.yaml ]; then
            corepack enable && pnpm i --frozen-lockfile
          else
            npm ci
          fi

      - if: env.SKIP != '1'
        working-directory: site
        run: |
          if [ -f prisma/schema.prisma ]; then
            npx prisma generate
          else
            echo "No Prisma schema found ‚Äî skipping generate"
          fi

      - if: env.SKIP != '1'
        working-directory: site
        run: vercel build --token="${{ env.VERCEL_TOKEN }}"


      - if: env.SKIP != '1'
        working-directory: site
        run: vercel deploy --prebuilt --token="${{ env.VERCEL_TOKEN }}"

  vercel_prod:
    needs: [detect, build_test]
    if: needs.detect.outputs.branch == 'dev'
    runs-on: ubuntu-latest
    env:
      VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          repository: ${{ needs.detect.outputs.repository }}
          ref: ${{ needs.detect.outputs.branch }}
          path: site

      - name: Derive REPO_KEY (UPPERCASE, '-' -> '_')
        id: repokey
        run: |
          NAME="${{ needs.detect.outputs.repository_name }}"
          KEY_UPPER="$(echo "$NAME" | tr '[:lower:]-' '[:upper:]_')"
          echo "KEY_UPPER=$KEY_UPPER" >> $GITHUB_OUTPUT

      - name: Load SITE_ENV__{REPO_KEY} and export Vercel IDs
        env:
          SITE_ENV: ${{ secrets[format('SITE_ENV__{0}', steps.repokey.outputs.KEY_UPPER)] }}
        working-directory: site
        run: |
          [ -n "${SITE_ENV:-}" ] || { echo "‚ùå Missing secret SITE_ENV__${{ steps.repokey.outputs.KEY_UPPER }}"; exit 1; }
          printf "%s\n" "$SITE_ENV" | sed 's/\r$//' > .site_env
          ORG="$(awk -F= '/^VERCEL_ORG_ID=/{print $2}' .site_env | tail -1)"
          PRJ="$(awk -F= '/^VERCEL_PROJECT_ID=/{print $2}' .site_env | tail -1)"
          [ -n "$ORG" ] || ORG="$(awk -F= '/^orgId=/{print $2}' .site_env | tail -1)"
          [ -n "$PRJ" ] || PRJ="$(awk -F= '/^projectId=/{print $2}' .site_env | tail -1)"
          [ -n "$ORG" ] && echo "VERCEL_ORG_ID=$ORG" >> $GITHUB_ENV || { echo "‚ùå VERCEL_ORG_ID missing"; exit 1; }
          [ -n "$PRJ" ] && echo "VERCEL_PROJECT_ID=$PRJ" >> $GITHUB_ENV || { echo "‚ùå VERCEL_PROJECT_ID missing"; exit 1; }

      - if: env.VERCEL_TOKEN == ''
        run: echo "‚ö†Ô∏è Missing Vercel token; skipping Vercel prod." && echo "SKIP=1" >> $GITHUB_ENV

      - if: env.SKIP != '1'
        working-directory: site
        run: npm i -g vercel

      - if: env.SKIP != '1'
        working-directory: site
        run: vercel pull --yes --environment=production --token="${{ env.VERCEL_TOKEN }}"

      - if: env.SKIP != '1'
        working-directory: site
        run: |
          : > .env
          if [ -f ".vercel/.env.production.local" ]; then
            cat .vercel/.env.production.local >> .env
          fi
          while IFS='=' read -r k v; do
            [ -z "$k" ] && continue
            [ "${k#\#}" != "$k" ] && continue
            if ! grep -qE "^${k}=" .env 2>/dev/null; then
              echo "${k}=${v}" >> .env
            fi
          done < .site_env
          echo "Prod .env (first lines):"; sed -n '1,20p' .env

      - name: Ensure DB vars (prod)
        if: env.SKIP != '1' && needs.detect.outputs.db_mode != 'none'
        working-directory: site
        run: |
          if ! grep -q '^DATABASE_URL=' .env; then
            VDB="$(awk -F= '$1=="DATABASE_URL_VERCEL"{print $2}' .site_env | tail -1)"
            [ -n "$VDB" ] && echo "DATABASE_URL=$VDB" >> .env
          fi
          if ! grep -q '^DIRECT_DATABASE_URL=' .env; then
            DDB="$(awk -F= '$1=="DIRECT_DATABASE_URL_VERCEL"{print $2}' .site_env | tail -1)"
            if [ -n "$DDB" ]; then
              echo "DIRECT_DATABASE_URL=$DDB" >> .env
            else
              DB="$(awk -F= '$1=="DATABASE_URL"{print $2}' .env | tail -1)"
              echo "DIRECT_DATABASE_URL=$DB" >> .env
            fi
          fi
          echo "Using DB envs:"; grep -E '^(DATABASE_URL|DIRECT_DATABASE_URL)=' .env

      - if: env.SKIP != '1'
        name: Install deps (for Prisma + Vercel build)
        working-directory: site
        run: |
          if [ -f yarn.lock ]; then
            yarn install --immutable
          elif [ -f pnpm-lock.yaml ]; then
            corepack enable && pnpm i --frozen-lockfile
          else
            npm ci
          fi

      - if: env.SKIP != '1'
        working-directory: site
        run: |
          if [ -f prisma/schema.prisma ]; then
            npx prisma generate
          else
            echo "No Prisma schema found ‚Äî skipping generate"
          fi

      - if: env.SKIP != '1'
        working-directory: site
        run: vercel build --prod --token="${{ env.VERCEL_TOKEN }}"


      - if: env.SKIP != '1'
        working-directory: site
        run: vercel deploy --prebuilt --prod --token="${{ env.VERCEL_TOKEN }}"

  # ---------------------------
  # Hetzner (unchanged logic)
  # ---------------------------
  image_build_push:
    needs: [detect, build_test]
    if: needs.detect.outputs.project_type == 'node' && needs.detect.outputs.branch == 'main-hetz'
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.meta.outputs.image }}
      ref:   ${{ steps.meta.outputs.ref }}
    steps:
      - uses: actions/checkout@v4
        with:
          repository: ${{ needs.detect.outputs.repository }}
          ref: ${{ needs.detect.outputs.branch }}
          path: site

      - name: Derive image coordinates
        id: meta
        run: |
          OWNER_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME="${{ needs.detect.outputs.repository_name }}"
          IMAGE="ghcr.io/${OWNER_LOWER}/${REPO_NAME}"
          SHORT="${GITHUB_SHA::7}"
          echo "image=$IMAGE" >> $GITHUB_OUTPUT
          echo "ref=$IMAGE:$SHORT" >> $GITHUB_OUTPUT

      - uses: docker/setup-buildx-action@v3

      - name: Derive REPO_KEY (UPPERCASE, '-' -> '_')
        id: repokey
        run: |
          NAME="${{ needs.detect.outputs.repository_name }}"
          KEY_UPPER="$(echo "$NAME" | tr '[:lower:]-' '[:upper:]_')"
          echo "KEY_UPPER=$KEY_UPPER" >> $GITHUB_OUTPUT

      - name: Export base URLs from SITE_ENV secret
        id: envparse
        env:
          SITE_ENV_SECRET: ${{ secrets[format('SITE_ENV__{0}', steps.repokey.outputs.KEY_UPPER)] }}
          DOMAIN: ${{ needs.detect.outputs.domain_prod }}
          ADMIN_DOMAIN: ${{ needs.detect.outputs.domain_admin }}
        run: |
          [ -n "${SITE_ENV_SECRET:-}" ] || { echo "‚ùå Missing SITE_ENV secret"; exit 1; }
          printf "%s\n" "$SITE_ENV_SECRET" | sed 's/\r$//' > .site_env
          get(){ awk -F= -v k="$1" '$1==k{print $2}' .site_env | tail -1; }
          NPU="$(get NEXT_PUBLIC_SITE_URL)";   [ -n "$NPU" ] || NPU="https://${DOMAIN}"
          NPA="$(get NEXT_PUBLIC_ADMIN_URL)";  [ -n "$NPA" ] || { [ -n "${ADMIN_DOMAIN:-}" ] && NPA="https://${ADMIN_DOMAIN}" || NPA=""; }
          SU="$(get SITE_URL)";                [ -n "$SU" ]  || SU="https://${DOMAIN}"
          echo "NEXT_PUBLIC_SITE_URL=$NPU"  >> $GITHUB_OUTPUT
          echo "NEXT_PUBLIC_ADMIN_URL=$NPA" >> $GITHUB_OUTPUT
          echo "SITE_URL=$SU"               >> $GITHUB_OUTPUT
          echo "Using base URLs:"; echo "$NPU"; echo "$NPA"; echo "$SU"

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build & push site image
        id: buildpush
        uses: docker/build-push-action@v6
        with:
          context: site
          push: true
          pull: true
          tags: |
            ${{ steps.meta.outputs.ref }}
            ${{ steps.meta.outputs.image }}:latest
          build-args: |
            NEXT_PUBLIC_SITE_URL=${{ steps.envparse.outputs.NEXT_PUBLIC_SITE_URL }}
            NEXT_PUBLIC_ADMIN_URL=${{ steps.envparse.outputs.NEXT_PUBLIC_ADMIN_URL }}
            SITE_URL=${{ steps.envparse.outputs.SITE_URL }}
            USE_DB=${{ needs.detect.outputs.db_mode != 'none' && 'true' || 'false' }}


  hetzner_node:
    needs: [detect, image_build_push]
    if: needs.detect.outputs.project_type == 'node' && needs.detect.outputs.branch == 'main-hetz'
    runs-on: ubuntu-latest
    steps:
      - name: Derive REPO_KEY (UPPERCASE, '-' -> '_')
        id: repokey
        run: |
          NAME="${{ needs.detect.outputs.repository_name }}"
          KEY_UPPER="$(echo "$NAME" | tr '[:lower:]-' '[:upper:]_')"
          echo "KEY_UPPER=$KEY_UPPER" >> $GITHUB_OUTPUT

      - name: Load SITE_ENV__{REPO_KEY} to env
        env:
          SITE_ENV_SECRET: ${{ secrets[format('SITE_ENV__{0}', steps.repokey.outputs.KEY_UPPER)] }}
        run: |
          [ -n "${SITE_ENV_SECRET:-}" ] || { echo "‚ùå Missing secret SITE_ENV__${{ steps.repokey.outputs.KEY_UPPER }}"; exit 1; }
          {
            echo 'SITE_ENV<<EOF'
            printf '%s\n' "$SITE_ENV_SECRET"
            echo 'EOF'
          } >> "$GITHUB_ENV"

      - name: Parse values from SITE_ENV (pgAdmin + Cloudflare)
        env:
          CF_SECRET_DIRECT: ${{ secrets.CF_DNS_API_TOKEN }}
          DB_MODE: ${{ needs.detect.outputs.db_mode }}
        run: |
          printf "%s\n" "$SITE_ENV" | sed 's/\r$//' > .site_env

          # Cloudflare token
          if [ -n "${CF_SECRET_DIRECT:-}" ]; then
            echo "CF_DNS_API_TOKEN=${CF_SECRET_DIRECT}" >> $GITHUB_ENV
          else
            CF_FROM_ENV="$(awk -F= '/^(CLOUDFLARE_DNS_API_TOKEN|CF_DNS_API_TOKEN)=/{print $2}' .site_env | tail -1)"
            [ -n "$CF_FROM_ENV" ] || { echo "‚ùå Cloudflare DNS token missing"; exit 1; }
            echo "CF_DNS_API_TOKEN=$CF_FROM_ENV" >> $GITHUB_ENV
          fi

          # pgAdmin only if DB enabled
          if [ "${DB_MODE}" != "none" ]; then
            PGADMIN_EMAIL="$(awk -F= '/^PGADMIN_EMAIL=/{print $2}' .site_env | tail -1)"
            PGADMIN_PASSWORD="$(awk -F= '/^PGADMIN_PASSWORD=/{print $2}' .site_env | tail -1)"
            [ -n "$PGADMIN_EMAIL" ]    || { echo "‚ùå PGADMIN_EMAIL missing in SITE_ENV"; exit 1; }
            [ -n "$PGADMIN_PASSWORD" ] || { echo "‚ùå PGADMIN_PASSWORD missing in SITE_ENV"; exit 1; }
            echo "PGADMIN_EMAIL=$PGADMIN_EMAIL"       >> $GITHUB_ENV
            echo "PGADMIN_PASSWORD=$PGADMIN_PASSWORD" >> $GITHUB_ENV
          else
            echo "DB disabled ‚Äî skipping pgAdmin variables"
          fi

      - name: Sanity check required SSH & parsed vars
        env:
          HZ_HOST:    ${{ secrets.HZ_HOST }}
          HZ_SSH_KEY: ${{ secrets.HZ_SSH_KEY }}
          DB_MODE:    ${{ needs.detect.outputs.db_mode }}
        run: |
          [ -n "${HZ_HOST:-}" ]  || { echo "‚ùå Missing secret: HZ_HOST"; exit 1; }
          [ -n "${HZ_SSH_KEY:-}" ] || { echo "‚ùå Missing secret: HZ_SSH_KEY"; exit 1; }
          [ -n "${CF_DNS_API_TOKEN:-}" ] || { echo "‚ùå CF_DNS_API_TOKEN not available"; exit 1; }
          if [ "${DB_MODE}" != "none" ]; then
            [ -n "${PGADMIN_EMAIL:-}" ]    || { echo "‚ùå PGADMIN_EMAIL not exported"; exit 1; }
            [ -n "${PGADMIN_PASSWORD:-}" ] || { echo "‚ùå PGADMIN_PASSWORD not exported"; exit 1; }
          fi

      - name: Resolve Hetzner public IPv4
        id: ipresolve
        env:
          HOST: ${{ secrets.HZ_HOST }}
        run: |
          set -euo pipefail
          H="$HOST"
          ip_re='^([0-9]{1,3}\.){3}[0-9]{1,3}$'
          if [[ "$H" =~ $ip_re ]]; then
            IP4="$H"
          else
            IP4="$(getent ahostsv4 "$H" | awk '{print $1; exit}' || true)"
            [ -n "$IP4" ] || IP4="$(dig +short A "$H" | head -1 || true)"
            if [ -z "$IP4" ] && command -v nslookup >/dev/null 2>&1; then
              IP4="$(nslookup -type=A "$H" 2>/dev/null | awk '/Address: /{print $2; exit}' || true)"
            fi
          fi
          [ -n "${IP4:-}" ] || { echo "‚ùå Could not resolve IPv4 for $H"; exit 1; }
          echo "PUBLIC_IPV4=$IP4" >> "$GITHUB_OUTPUT"
          echo "Resolved IPv4: $IP4"

      - name: Ensure Cloudflare DNS (root, www, admin, pgadmin)
        env:
          CF_TOKEN:   ${{ env.CF_DNS_API_TOKEN }}
          ROOT:       ${{ needs.detect.outputs.domain_prod }}
          ADMIN:      ${{ needs.detect.outputs.domain_admin }}
          PGADMIN:    ${{ needs.detect.outputs.domain_pgadmin }}
          IP4:        ${{ steps.ipresolve.outputs.PUBLIC_IPV4 }}
          DB_MODE:    ${{ needs.detect.outputs.db_mode }}
        run: |
          set -euo pipefail
          api(){ curl -sS -H "Authorization: Bearer $CF_TOKEN" -H "Content-Type: application/json" "$@"; }
          ZONE_NAME="$ROOT"
          if [ "$(echo "$ZONE_NAME" | awk -F. '{print NF}')" -gt 2 ]; then
            ZONE_NAME="$(echo "$ZONE_NAME" | awk -F. '{print $(NF-1)"."$NF}')"
          fi
          ZID=$(api "https://api.cloudflare.com/client/v4/zones?name=${ZONE_NAME}" | jq -r '.result[0].id')
          [ "$ZID" != "null" ] && [ -n "$ZID" ] || { echo "‚ùå Zone ${ZONE_NAME} not found in Cloudflare"; exit 1; }

          upsert_a(){
            local name="$1"; local ip="$2"; local proxied="${3:-true}"
            local rid=$(api "https://api.cloudflare.com/client/v4/zones/$ZID/dns_records?type=A&name=${name}" | jq -r '.result[0].id')
            if [ "$rid" = "null" ] || [ -z "$rid" ]; then
              echo "Create A ${name} -> ${ip}"
              api -X POST "https://api.cloudflare.com/client/v4/zones/$ZID/dns_records" \
                --data "{\"type\":\"A\",\"name\":\"${name}\",\"content\":\"${ip}\",\"ttl\":120,\"proxied\":${proxied}}" >/dev/null
            else
              echo "Update A ${name} -> ${ip}"
              api -X PUT "https://api.cloudflare.com/client/v4/zones/$ZID/dns_records/${rid}" \
                --data "{\"type\":\"A\",\"name\":\"${name}\",\"content\":\"${ip}\",\"ttl\":120,\"proxied\":${proxied}}" >/dev/null
            fi
          }

          upsert_a "${ROOT}"      "$IP4" true
          upsert_a "www.${ROOT}"  "$IP4" true
          upsert_a "${ADMIN}"     "$IP4" true
          if [ "${DB_MODE}" != "none" ]; then
            upsert_a "${PGADMIN}"   "$IP4" true
          else
            echo "DB disabled ‚Äî skipping pgAdmin DNS"
          fi

          echo "‚úÖ DNS records ensured (pgAdmin conditional on DB mode)"

      - name: Deploy over SSH (Traefik + per-project DB + app + pgAdmin)
        uses: appleboy/ssh-action@v1
        env:
          SLUG:         ${{ needs.detect.outputs.slug }}
          PORT:         ${{ needs.detect.outputs.port }}
          DOMAIN:       ${{ needs.detect.outputs.domain_prod }}
          ADMIN_DOMAIN: ${{ needs.detect.outputs.domain_admin }}
          PGADMIN_HOST: ${{ needs.detect.outputs.domain_pgadmin }}
          IMAGE_REF:    ${{ needs.image_build_push.outputs.ref }}
          SITE_ENV:     ${{ env.SITE_ENV }}
          GHCR_USER:    ${{ github.repository_owner }}
          GHCR_TOKEN:   ${{ secrets.GHCR_READ_TOKEN || secrets.GITHUB_TOKEN }}
          CF_DNS_API_TOKEN: ${{ env.CF_DNS_API_TOKEN }}
          PGADMIN_EMAIL:    ${{ env.PGADMIN_EMAIL }}
          PGADMIN_PASSWORD: ${{ env.PGADMIN_PASSWORD }}
          DB_MODE:          ${{ needs.detect.outputs.db_mode }}
        with:
          host: ${{ secrets.HZ_HOST }}
          username: ${{ secrets.HZ_USER || 'root' }}
          key: ${{ secrets.HZ_SSH_KEY }}
          port: 22
          timeout: 60s
          command_timeout: 25m
          envs: SLUG,PORT,DOMAIN,ADMIN_DOMAIN,PGADMIN_HOST,IMAGE_REF,SITE_ENV,GHCR_USER,GHCR_TOKEN,CF_DNS_API_TOKEN,PGADMIN_EMAIL,PGADMIN_PASSWORD,DB_MODE
          script: |
            set -euo pipefail

            # Basic required vars
            [ -n "${SLUG:-}" ] && [ -n "${DOMAIN:-}" ] && [ -n "${IMAGE_REF:-}" ] || { echo "‚ùå Missing SLUG/DOMAIN/IMAGE_REF"; exit 1; }

            SLUG_SAFE="$(printf '%s' "${SLUG}" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9-]+/-/g; s/^-+//; s/-+$//')"
            [ -n "$SLUG_SAFE" ] || { echo "‚ùå Bad SLUG"; exit 1; }

            DB_NET="${SLUG_SAFE}_db_net"
            DB_DIR="/opt/services/postgres-${SLUG_SAFE}"
            SITE_DIR="/opt/sites/${SLUG_SAFE}"

            docker network create proxy >/dev/null 2>&1 || true
            if [ "${DB_MODE}" != "none" ]; then
              docker network create "${DB_NET}" >/dev/null 2>&1 || true
            fi

            # Normalize SITE_ENV
            SITE_ENV_NORM="$(printf "%s" "${SITE_ENV:-}" | sed 's/\r$//')"
            ACME_EMAIL="$(printf "%s" "$SITE_ENV_NORM" | awk -F= '/^ACME_EMAIL=/{print $2}' | tail -1)"
            [ -n "$ACME_EMAIL" ] || { echo "‚ùå ACME_EMAIL missing in SITE_ENV"; exit 1; }

            DB_NAME="$(printf "%s" "$SITE_ENV_NORM" | awk -F= '/^(POSTGRES_DB|DB_NAME)=/{print $2}' | tail -1)"
            [ -n "$DB_NAME" ] || DB_NAME="${SLUG_SAFE}"
            DB_USER="$(printf "%s" "$SITE_ENV_NORM" | awk -F= '/^(POSTGRES_USER|DB_USER)=/{print $2}' | tail -1)"
            [ -n "$DB_USER" ] || DB_USER="${SLUG_SAFE}_admin"
            DB_PASS="$(printf "%s" "$SITE_ENV_NORM" | awk -F= '/^(POSTGRES_PASSWORD|DB_PASSWORD)=/{print $2}' | tail -1)"
            [ -n "$DB_PASS" ] || DB_PASS=""

            # --- Traefik (shared) ---
            TDIR="/opt/services/traefik"
            mkdir -p "$TDIR/letsencrypt"
            [ -f "$TDIR/letsencrypt/acme.json" ] || install -m 600 /dev/null "$TDIR/letsencrypt/acme.json"

            cat > "$TDIR/.env" <<-TRAEFIK_ENV
            ACME_EMAIL=${ACME_EMAIL}
            CF_DNS_API_TOKEN=${CF_DNS_API_TOKEN}
            CLOUDFLARE_DNS_API_TOKEN=${CF_DNS_API_TOKEN}
            TRAEFIK_ENV

            cat > "$TDIR/docker-compose.yml" <<-'TRAEFIK_YML'
            services:
              traefik:
                image: traefik:v3.0
                restart: unless-stopped
                env_file: .env
                command:
                  - --providers.docker=true
                  - --providers.docker.exposedbydefault=false
                  - --entrypoints.web.address=:80
                  - --entrypoints.websecure.address=:443
                  - --certificatesresolvers.le.acme.email=${ACME_EMAIL}
                  - --certificatesresolvers.le.acme.storage=/letsencrypt/acme.json
                  - --certificatesresolvers.le.acme.dnschallenge=true
                  - --certificatesresolvers.le.acme.dnschallenge.provider=cloudflare
                  - --certificatesresolvers.le.acme.dnschallenge.delaybeforecheck=10
                environment:
                  CF_DNS_API_TOKEN: ${CF_DNS_API_TOKEN}
                  CLOUDFLARE_DNS_API_TOKEN: ${CLOUDFLARE_DNS_API_TOKEN}
                ports:
                  - "80:80"
                  - "443:443"
                volumes:
                  - /var/run/docker.sock:/var/run/docker.sock:ro
                  - ./letsencrypt:/letsencrypt
                networks:
                  - proxy

            networks:
              proxy:
                external: true
                name: proxy
            TRAEFIK_YML

            (cd "$TDIR" && docker compose up -d)

            # --- Login to GHCR (if token provided) ---
            if [ -n "${GHCR_TOKEN:-}" ]; then
              echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USER" --password-stdin
            fi

            # ============================================
            # DB stack only if DB_MODE != none
            # ============================================
            if [ "${DB_MODE}" != "none" ]; then
              echo "üîπ DB enabled ‚Äî setting up Postgres + PgBouncer + pgAdmin"
              mkdir -p "${DB_DIR}"

              {
                echo "POSTGRES_USER=${DB_USER}"
                echo "POSTGRES_PASSWORD=${DB_PASS}"
                echo "POSTGRES_DB=${DB_NAME}"
                echo "DB_USER=${DB_USER}"
                echo "DB_PASSWORD=${DB_PASS}"
                echo "DB_NAME=${DB_NAME}"
                echo "PGADMIN_DEFAULT_EMAIL=${PGADMIN_EMAIL}"
                echo "PGADMIN_DEFAULT_PASSWORD=${PGADMIN_PASSWORD}"
                echo "PGADMIN_DEFAULT_SERVER_NAME=PgBouncer (${SLUG_SAFE})"
              } > "${DB_DIR}/.env"

              {
                echo '{'
                echo '  "Servers": {'
                echo '    "1": {'
                echo "      \"Name\": \"PgBouncer (${SLUG_SAFE})\","
                echo '      "Group": "Servers",'
                echo '      "Host": "pgbouncer",'
                echo '      "Port": 5432,'
                echo "      \"MaintenanceDB\": \"${DB_NAME}\","
                echo "      \"Username\": \"${DB_USER}\","
                echo '      "SSLMode": "prefer"'
                echo '    }'
                echo '  }'
                echo '}'
              } > "${DB_DIR}/pgadmin-servers.json"

              {
                echo "services:"
                echo "  postgres:"
                echo "    image: postgres:15"
                echo "    restart: unless-stopped"
                echo "    env_file: .env"
                echo "    environment:"
                echo '      POSTGRES_INITDB_ARGS: "--auth=scram-sha-256"'
                echo "    healthcheck:"
                echo '      test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB"]'
                echo "      interval: 10s"
                echo "      timeout: 5s"
                echo "      retries: 30"
                echo "    volumes:"
                echo "      - pg_data_${SLUG_SAFE}:/var/lib/postgresql/data"
                echo "    networks:"
                echo "      - ${DB_NET}"
                echo
                echo "  pgbouncer:"
                echo "    image: edoburu/pgbouncer"
                echo "    restart: unless-stopped"
                echo "    env_file: .env"
                echo "    environment:"
                echo "      POOL_MODE: transaction"
                echo "      MAX_CLIENT_CONN: 200"
                echo "      DEFAULT_POOL_SIZE: 20"
                echo "      AUTH_TYPE: scram-sha-256"
                echo "      DB_HOST: postgres"
                echo "      DB_USER: \${POSTGRES_USER}"
                echo "      DB_PASSWORD: \${POSTGRES_PASSWORD}"
                echo "    depends_on:"
                echo "      postgres:"
                echo "        condition: service_healthy"
                echo "    networks:"
                echo "      - ${DB_NET}"
                echo
                echo "  pgadmin:"
                echo "    image: dpage/pgadmin4:8"
                echo "    restart: unless-stopped"
                echo "    env_file: .env"
                echo "    environment:"
                echo '      PGADMIN_LISTEN_PORT: "8080"'
                echo '      PGADMIN_CONFIG_ENABLE_PROXY_FIX: "True"'
                echo "    volumes:"
                echo "      - ./pgadmin-servers.json:/pgadmin4/servers.json:ro"
                echo "      - pgadmin_data_${SLUG_SAFE}:/var/lib/pgadmin"
                echo "    networks:"
                echo "      - ${DB_NET}"
                echo "      - proxy"
                echo "    labels:"
                echo "      - 'traefik.enable=true'"
                echo "      - 'traefik.docker.network=proxy'"
                echo "      - 'traefik.http.routers.${SLUG_SAFE}-pgadmin.rule=Host(\"${PGADMIN_HOST}\")'"
                echo "      - 'traefik.http.routers.${SLUG_SAFE}-pgadmin.entrypoints=websecure'"
                echo "      - 'traefik.http.routers.${SLUG_SAFE}-pgadmin.tls.certresolver=le'"
                echo "      - 'traefik.http.services.${SLUG_SAFE}-pgadmin.loadbalancer.server.port=8080'"
                echo
                echo "volumes:"
                echo "  pg_data_${SLUG_SAFE}:"
                echo "  pgadmin_data_${SLUG_SAFE}:"
                echo
                echo "networks:"
                echo "  ${DB_NET}:"
                echo "    external: true"
                echo "    name: ${DB_NET}"
                echo "  proxy:"
                echo "    external: true"
                echo "    name: proxy"
              } > "${DB_DIR}/docker-compose.yml"


              (cd "${DB_DIR}" && docker compose up -d)
            else
              echo "üö´ DB disabled ‚Äî skipping Postgres/PgBouncer/pgAdmin setup"
            fi

            # ============================================
            # App deploy (common)
            # ============================================
            mkdir -p "${SITE_DIR}"
            cd "${SITE_DIR}"
            printf "%s\n" "$SITE_ENV_NORM" > app.env

            # Basic shared env setup
            grep -q '^AUTH_TRUST_HOST=' app.env || echo 'AUTH_TRUST_HOST=true' >> app.env
            grep -q '^NEXTAUTH_URL_PUBLIC=' app.env || echo "NEXTAUTH_URL_PUBLIC=https://${DOMAIN}" >> app.env
            if [ -n "${ADMIN_DOMAIN:-}" ]; then
              grep -q '^NEXTAUTH_URL_ADMIN=' app.env || echo "NEXTAUTH_URL_ADMIN=https://${ADMIN_DOMAIN}" >> app.env
            fi
            # Expose the base domain for seed script
            grep -q '^SITE_DOMAIN=' app.env || echo "SITE_DOMAIN=${DOMAIN}" >> app.env


            # Inject DB URLs only if DB enabled
            if [ "${DB_MODE}" != "none" ]; then
              grep -q '^DATABASE_URL=' app.env || echo "DATABASE_URL=postgresql://${DB_USER}:${DB_PASS}@pgbouncer:5432/${DB_NAME}?pgbouncer=true&connection_limit=1&connect_timeout=5" >> app.env
              grep -q '^DIRECT_DATABASE_URL=' app.env || echo "DIRECT_DATABASE_URL=postgresql://${DB_USER}:${DB_PASS}@postgres:5432/${DB_NAME}?connect_timeout=5" >> app.env
            fi

            # --- Compose template (DB-aware) ---
            if [ "${DB_MODE}" != "none" ]; then
              NET_LINE="- ${DB_NET}"
            else
              NET_LINE=""
            fi

            cat > docker-compose.yml.tpl <<-'APP_COMPOSE_YML'
            services:
              app:
                image: ${IMAGE_REF}
                restart: unless-stopped
                env_file:
                  - app.env
                labels:
                  - 'traefik.enable=true'
                  - 'traefik.docker.network=proxy'
                  - 'traefik.http.routers.${SLUG_SAFE}.rule=Host("${DOMAIN}") || Host("www.${DOMAIN}")'
                  - 'traefik.http.routers.${SLUG_SAFE}.entrypoints=websecure'
                  - 'traefik.http.routers.${SLUG_SAFE}.tls.certresolver=le'
                  - 'traefik.http.services.${SLUG_SAFE}.loadbalancer.server.port=${PORT}'
                networks:
                  - proxy
            APP_COMPOSE_YML

                        if [ "${DB_MODE}" != "none" ]; then
                          echo "      ${NET_LINE}" >> docker-compose.yml.tpl
                        fi

                        echo "networks:" >> docker-compose.yml.tpl
                        echo "  proxy: { external: true, name: proxy }" >> docker-compose.yml.tpl
                        if [ "${DB_MODE}" != "none" ]; then
                          echo "  ${DB_NET}: { external: true, name: ${DB_NET} }" >> docker-compose.yml.tpl
                        fi

                        export IMAGE_REF SLUG_SAFE DOMAIN PORT DB_NET
                        if ! command -v envsubst >/dev/null 2>&1; then
                          apt-get update -y && apt-get install -y --no-install-recommends gettext-base
                        fi
                        envsubst '$IMAGE_REF $SLUG_SAFE $DOMAIN $PORT $DB_NET' < docker-compose.yml.tpl > docker-compose.yml

                        docker compose pull || true
                        docker compose up -d --remove-orphans

                        # --- Prisma migrate + Admin ensure (only if DB enabled) ---
                        if [ "${DB_MODE}" != "none" ]; then
                          docker compose exec -T app sh -s <<-'PRISMA_SH'
                        set -e
                        NODE_PATH=/app/node_modules npx prisma migrate deploy

                        # Optional admin seeding ‚Äì configurable per project via env
                        NODE_PATH=/app/node_modules node <<-'NODE_ADMIN'
                        (async () => {
                          const { PrismaClient } = require("@prisma/client");
                          const bcrypt = require("bcryptjs");
                          const prisma = new PrismaClient();

                          // Turn off seeding for a project with ADMIN_ENABLED=false in SITE_ENV
                          const enabledFlag = (process.env.ADMIN_ENABLED ?? "true").toLowerCase();
                          if (["false", "0", "no"].includes(enabledFlag)) {
                            console.log("‚ÑπÔ∏è ADMIN_ENABLED is false ‚Äî skipping admin seed");
                            await prisma.$disconnect();
                            return;
                          }

                          const siteDomain =
                            (process.env.SITE_DOMAIN || "")
                              .replace(/^https?:\/\//, "")
                              .replace(/\/.*/, "") || "example.com";

                          const email = (process.env.ADMIN_EMAIL || `admin@${siteDomain}`).toLowerCase();
                          const name  = process.env.ADMIN_NAME       || "Head Admin";
                          const plain = process.env.ADMIN_PASSWORD   || "supersecurepassword";
                          const role  = process.env.ADMIN_ROLE       || "admin";  // your User.role is String

                          const existing = await prisma.user.findUnique({ where: { email } });
                          const passwordHash = await bcrypt.hash(plain, 12);

                          if (!existing) {
                            await prisma.user.create({
                              data: {
                                email,
                                name,
                                role,
                                passwordHash,
                              },
                            });
                            console.log("‚úÖ Created admin:", email);
                          } else {
                            await prisma.user.update({
                              where: { email },
                              data: {
                                name,
                                role,
                                passwordHash,
                              },
                            });
                            console.log("‚úÖ Updated admin:", email);
                          }

                          await prisma.$disconnect();
                        })().catch(e => {
                          console.error(e);
                          process.exit(1);
                        });
                        NODE_ADMIN
                        PRISMA_SH
                        else
                          echo "üö´ DB disabled ‚Äî skipping Prisma migrations and admin seed"
                        fi

      - name: In-container health check (bypasses DNS/SSL)
        uses: appleboy/ssh-action@v1
        env:
          SLUG:   ${{ needs.detect.outputs.slug }}
          DOMAIN: ${{ needs.detect.outputs.domain_prod }}
        with:
          host: ${{ secrets.HZ_HOST }}
          username: ${{ secrets.HZ_USER || 'root' }}
          key: ${{ secrets.HZ_SSH_KEY }}
          port: 22
          timeout: 60s
          command_timeout: 10m
          envs: SLUG,DOMAIN
          script: |
            set -euo pipefail
            : "${SLUG:?missing SLUG}"
            : "${DOMAIN:?missing DOMAIN}"

            SLUG_SAFE="$(printf '%s' "${SLUG}" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9-]+/-/g; s/^-+//; s/-+$//')"
            cd "/opt/sites/${SLUG_SAFE}"

            PORT=$(docker compose exec -T app sh -lc 'printf "%s" "${PORT:-3000}"')
            echo "Detected PORT=$PORT"

            ok=0
            for path in /api/healthz /api/healthz/ /; do
              echo "Probing http://127.0.0.1:${PORT}${path}"
              for i in $(seq 1 20); do
                if docker compose exec -T app node -e "const http=require('http');http.get({host:'127.0.0.1',port:${PORT},path:'${path}',headers:{'x-forwarded-proto':'https','host':'${DOMAIN:-localhost}'}},r=>process.exit(r.statusCode<400?0:1)).on('error',()=>process.exit(1))"; then
                  echo '‚úÖ OK'; ok=1; break
                fi
                echo "  retry $i"; sleep 3
              done
              [ $ok -eq 1 ] && break
            done
            [ $ok -eq 1 ] || { echo "‚ùå App not healthy internally"; docker compose logs --no-color --tail=200 app || true; exit 1; }

      - name: Short settle
        run: sleep 10

      - name: Public health check (through Traefik)
        env:
          DOMAIN: ${{ needs.detect.outputs.domain_prod }}
        run: |
          set -e
          urls=("https://${DOMAIN}/api/healthz" "https://${DOMAIN}/")
          ok=0
          for i in {1..36}; do
            for u in "${urls[@]}"; do
              code=$(curl -L -sS -o /tmp/health_body -w "%{http_code}" "$u" || true)
              echo "GET $u -> HTTP $code"
              if grep -q "404 page not found" /tmp/health_body 2>/dev/null; then
                echo "Traefik 404 (router warming/rule) ‚Äî retrying‚Ä¶"
              fi
              [[ "$code" =~ ^(200|204|301|302|307|308)$ ]] && { echo "‚úÖ Public health OK ($code)"; ok=1; break; }
            done
            [ $ok -eq 1 ] && break
            sleep 5
          done
          [ $ok -eq 1 ] || { echo "‚ùå Public health failed"; exit 1; }

  hetzner_static:
    needs: [detect, build_test]
    if: needs.detect.outputs.project_type == 'static' && needs.detect.outputs.branch == 'main-hetz'
    runs-on: ubuntu-latest
    env:
      SLUG:   ${{ needs.detect.outputs.slug }}
      DOMAIN: ${{ needs.detect.outputs.domain_prod }}
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: static-export

      - name: Move artifact to ./out
        run: |
          rm -rf out && mkdir -p out
          cp -R static-export/. out/

      - name: Create Dockerfile for static image
        run: |
          cat > site.Dockerfile <<'DOCKER'
          FROM nginx:alpine
          COPY out/ /usr/share/nginx/html
          RUN adduser -D -g 'www' www \
           && chown -R www:www /usr/share/nginx/html \
           && sed -i 's/user  nginx;/user www;/' /etc/nginx/nginx.conf
          EXPOSE 80
          DOCKER

      - uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build & push static image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: site.Dockerfile
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/static-${{ needs.detect.outputs.repository_name }}:${{ github.sha }}
            ghcr.io/${{ github.repository_owner }}/static-${{ needs.detect.outputs.repository_name }}:latest

      - name: Deploy static container on Hetzner (HTTPS only)
        uses: appleboy/ssh-action@v1
        env:
          SLUG: ${{ needs.detect.outputs.slug }}
          DOMAIN: ${{ needs.detect.outputs.domain_prod }}
          IMAGE_REF: ghcr.io/${{ github.repository_owner }}/static-${{ needs.detect.outputs.repository_name }}:${{ github.sha }}
          GHCR_USER: ${{ github.repository_owner }}
          GHCR_TOKEN: ${{ secrets.GHCR_READ_TOKEN || secrets.GITHUB_TOKEN }}
        with:
          host: ${{ secrets.HETZNER_HOST || secrets.HZ_HOST }}
          username: ${{ secrets.HETZNER_USER || secrets.HZ_USER || 'root' }}
          key: ${{ secrets.HETZNER_SSH_KEY || secrets.HZ_SSH_KEY }}
          port: 22
          timeout: 60s
          command_timeout: 15m
          envs: SLUG,DOMAIN,IMAGE_REF,GHCR_USER,GHCR_TOKEN
          script: |
            set -euo pipefail
            docker network create proxy >/dev/null 2>&1 || true
            if [ -n "${GHCR_TOKEN:-}" ]; then
              echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USER" --password-stdin
            fi
            SLUG_SAFE="$(printf '%s' "${SLUG}" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9-]+/-/g; s/^-+//; s/-+$//')"
            SITE_DIR="/opt/sites/${SLUG_SAFE}"
            mkdir -p "$SITE_DIR"
            cd "$SITE_DIR"

            cat > docker-compose.yml.tpl <<'EOF'
            services:
              web:
                image: ${IMAGE_REF}
                restart: unless-stopped
                labels:
                  - 'traefik.enable=true'
                  - 'traefik.docker.network=proxy'
                  - 'traefik.http.routers.${SLUG_SAFE}.rule=Host("${DOMAIN}")'
                  - 'traefik.http.routers.${SLUG_SAFE}.entrypoints=websecure'
                  - 'traefik.http.routers.${SLUG_SAFE}.tls.certresolver=le'
                  - 'traefik.http.services.${SLUG_SAFE}.loadbalancer.server.port=80'
                  - 'traefik.http.routers.${SLUG_SAFE}-http.rule=Host("${DOMAIN}")'
                  - 'traefik.http.routers.${SLUG_SAFE}-http.entrypoints=web'
                  - 'traefik.http.routers.${SLUG_SAFE}-http.middlewares=${SLUG_SAFE}-redirect'
                  - 'traefik.http.routers.${SLUG_SAFE}-http.service=${SLUG_SAFE}'
                  - 'traefik.http.middlewares.${SLUG_SAFE}-redirect.redirectscheme.scheme=https'
                networks:
                  - proxy
            networks:
              proxy:
                external: true
                name: proxy
            EOF
            export IMAGE_REF SLUG_SAFE DOMAIN
            if ! command -v envsubst >/dev/null 2>&1; then
              apt-get update -y && apt-get install -y --no-install-recommends gettext-base
            fi
            envsubst '$IMAGE_REF $SLUG_SAFE $DOMAIN' < docker-compose.yml.tpl > docker-compose.yml

            docker compose pull || true
            docker compose up -d --remove-orphans

      - name: Static public check
        run: |
          for i in {1..36}; do
            if curl -L -sS "https://${{ needs.detect.outputs.domain_prod }}/" >/dev/null; then
              echo "‚úÖ Site up"; exit 0; fi
            echo "retry $i"; sleep 5
          done
          echo "‚ùå Timed out"; exit 1

      - name: Trigger Receive & Deploy (post-Hetzner static)
        if: needs.detect.outputs.branch == 'main-hetz' && success()
        run: |
          curl -sS -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: token ${{ secrets.CICD_DISPATCH_TOKEN }}" \
            https://api.github.com/repos/CICD/multi-site-hetz-cicd/dispatches \
            -d @- <<'JSON'
          {
            "event_type": "deploy",
            "client_payload": {
              "repository": "${{ needs.detect.outputs.repository }}",
              "repository_name": "${{ needs.detect.outputs.repository_name }}",
              "branch": "${{ needs.detect.outputs.branch }}"
            }
          }
          JSON
      - run: echo "Hetzner deploy steps unchanged; using your existing definitions."
