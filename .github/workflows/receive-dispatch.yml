name: Receive & Deploy to Hetzner

on:
  repository_dispatch:
    types: [ deploy ]

permissions:
  contents: read
  packages: write
  actions: read

concurrency:
  group: hetz-${{ github.event.client_payload.repository_name }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Extract payload
        id: p
        run: |
          echo "repository=${{ github.event.client_payload.repository }}" >> $GITHUB_OUTPUT
          echo "repository_name=${{ github.event.client_payload.repository_name }}" >> $GITHUB_OUTPUT
          echo "branch=${{ github.event.client_payload.branch }}" >> $GITHUB_OUTPUT

      - name: Checkout target website repo
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.p.outputs.repository }}
          ref: ${{ steps.p.outputs.branch }}
          path: site

      - name: Read .cicd-config.yml (slug / port / domains.prod / domains.admin)
        id: cfg
        shell: bash
        run: |
          cd site
          SLUG="site"
          PORT="3000"
          DOMAIN_PROD=""
          DOMAIN_ADMIN=""

          if [ -f ".cicd-config.yml" ]; then
            get_val(){ grep -E "^$1:" .cicd-config.yml | head -1 | awk -F': *' '{print $2}' | tr -d "\"'"; }
            SLUG=$(get_val slug || echo "$SLUG")
            PORT=$(get_val port || echo "$PORT")
            DOM_BLOCK="$(awk '/^domains:/{f=1;next} f && /^[^ ]/{f=0} f{print}' .cicd-config.yml)"
            DOMAIN_PROD="$(printf '%s\n' "$DOM_BLOCK" | awk '/prod:/{print $2}' | tr -d "\"'")"
            DOMAIN_ADMIN="$(printf '%s\n' "$DOM_BLOCK" | awk '/admin:/{print $2}' | tr -d "\"'")"
          fi

          echo "SLUG=$SLUG" >> $GITHUB_OUTPUT
          echo "PORT=$PORT" >> $GITHUB_OUTPUT
          echo "DOMAIN_PROD=$DOMAIN_PROD" >> $GITHUB_OUTPUT
          echo "DOMAIN_ADMIN=$DOMAIN_ADMIN" >> $GITHUB_OUTPUT

      - name: Gate – only handle prod (main-hetz) deploys
        if: steps.p.outputs.branch != 'main-hetz'
        run: |
          echo "ℹ️ Branch '${{ steps.p.outputs.branch }}' is not main-hetz. Skipping."
          exit 0

      - name: Guard required secrets
        if: steps.p.outputs.branch == 'main-hetz'
        run: |
          test -n "${{ secrets.HZ_HOST }}"            || { echo "❌ Missing secret: HZ_HOST"; exit 1; }
          test -n "${{ secrets.HZ_SSH_KEY }}"         || { echo "❌ Missing secret: HZ_SSH_KEY"; exit 1; }
          test -n "${{ secrets.TRAEFIK_ACME_EMAIL }}" || { echo "❌ Missing secret: TRAEFIK_ACME_EMAIL"; exit 1; }
          test -n "${{ secrets.CF_API_TOKEN }}"       || { echo "❌ Missing secret: CF_API_TOKEN"; exit 1; }

      - name: Derive image coordinates
        if: steps.p.outputs.branch == 'main-hetz'
        id: meta
        shell: bash
        run: |
          OWNER_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME="${{ steps.p.outputs.repository_name }}"
          IMAGE="ghcr.io/${OWNER_LOWER}/${REPO_NAME}"
          SHORT="${GITHUB_SHA::7}"
          echo "image=$IMAGE"      >> $GITHUB_OUTPUT
          echo "ref=$IMAGE:$SHORT" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        if: steps.p.outputs.branch == 'main-hetz'
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR (push)
        if: steps.p.outputs.branch == 'main-hetz'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build & push site image
        if: steps.p.outputs.branch == 'main-hetz'
        uses: docker/build-push-action@v6
        with:
          context: site
          push: true
          tags: |
            ${{ steps.meta.outputs.ref }}
            ${{ steps.meta.outputs.image }}:latest

      - name: Compute site env secret key (multiline .env)
        if: steps.p.outputs.branch == 'main-hetz'
        id: k
        shell: bash
        run: |
          REPO_NAME="${{ steps.p.outputs.repository_name }}"
          KEY="$(echo "$REPO_NAME" | tr '[:lower:]-' '[:upper:]_')"  # drcodezenna -> DRCODEZENNA
          echo "SITE_ENV_KEY=SITE_ENV__${KEY}" >> $GITHUB_OUTPUT
          echo "Resolved env secret key: SITE_ENV__${KEY}"

      - name: Deploy over SSH (Traefik + DB + app; safe env write)
        if: steps.p.outputs.branch == 'main-hetz'
        uses: appleboy/ssh-action@v1
        env:
          SLUG:         ${{ steps.cfg.outputs.SLUG }}
          PORT:         ${{ steps.cfg.outputs.PORT }}
          DOMAIN:       ${{ steps.cfg.outputs.DOMAIN_PROD }}
          ADMIN_DOMAIN: ${{ steps.cfg.outputs.DOMAIN_ADMIN }}
          IMAGE_REF:    ${{ steps.meta.outputs.ref }}
          SITE_ENV:     ${{ secrets[steps.k.outputs.SITE_ENV_KEY] }}
          GHCR_USER:    ${{ github.repository_owner }}
          GHCR_TOKEN:   ${{ secrets.GHCR_READ_TOKEN || secrets.GITHUB_TOKEN }}
          ACME_EMAIL:   ${{ secrets.TRAEFIK_ACME_EMAIL }}
          CF_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
        with:
          host: ${{ secrets.HZ_HOST }}
          username: ${{ secrets.HZ_USER || 'root' }}
          key: ${{ secrets.HZ_SSH_KEY }}
          port: 22
          timeout: 60s
          command_timeout: 20m
          envs: SLUG,PORT,DOMAIN,ADMIN_DOMAIN,IMAGE_REF,SITE_ENV,GHCR_USER,GHCR_TOKEN,ACME_EMAIL,CF_API_TOKEN
          script: |
            # POSIX sh
            set -e

            case "${ACME_EMAIL}" in ""|*example.com*) echo "❌ TRAEFIK_ACME_EMAIL must be a real email"; exit 1;; esac
            [ -n "${SLUG:-}" ] && [ -n "${DOMAIN:-}" ] && [ -n "${IMAGE_REF:-}" ] || { echo "❌ Missing SLUG/DOMAIN/IMAGE_REF"; exit 1; }

            echo "Deploying ${SLUG} → https://${DOMAIN} (image: ${IMAGE_REF})"

            # --- Networks (idempotent) ---
            docker network create proxy >/dev/null 2>&1 || true
            docker network create core_db_net >/dev/null 2>&1 || true

            # --- Traefik (DNS-01 via Cloudflare) ---
            TDIR="/opt/services/traefik"
            mkdir -p "$TDIR/letsencrypt"
            [ -f "$TDIR/letsencrypt/acme.json" ] || install -m 600 /dev/null "$TDIR/letsencrypt/acme.json"
            cat > "$TDIR/.env" <<EOF
            ACME_EMAIL=${ACME_EMAIL}
            CLOUDFLARE_DNS_API_TOKEN=${CF_API_TOKEN}
            CF_DNS_API_TOKEN=${CF_API_TOKEN}
            EOF

            cat > "$TDIR/docker-compose.yml" <<'YAML'
            services:
              traefik:
                image: traefik:v3.0
                restart: unless-stopped
                env_file: .env
                command:
                  - --providers.docker=true
                  - --providers.docker.exposedbydefault=false
                  - --entrypoints.web.address=:80
                  - --entrypoints.websecure.address=:443
                  - --certificatesresolvers.le.acme.dnschallenge=true
                  - --certificatesresolvers.le.acme.dnschallenge.provider=cloudflare
                  - --certificatesresolvers.le.acme.email=${ACME_EMAIL}
                  - --certificatesresolvers.le.acme.storage=/letsencrypt/acme.json
                ports:
                  - 80:80
                  - 443:443
                volumes:
                  - /var/run/docker.sock:/var/run/docker.sock:ro
                  - ./letsencrypt:/letsencrypt
                networks: [proxy]
            networks:
              proxy:
                external: true
                name: proxy
            YAML
            (cd "$TDIR" && docker compose up -d)
            docker logs --since=2m traefik-traefik-1 | egrep -i 'acme|lego|dns-01|certificate|error' || true

            # --- GHCR login (pulls) ---
            if [ -n "${GHCR_TOKEN:-}" ]; then
              echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USER" --password-stdin
            fi

            # --- App secrets file (avoid $ expansion) ---
            SITE_DIR="/opt/sites/${SLUG}"
            mkdir -p "$SITE_DIR"
            cd "$SITE_DIR"
            printf "%s\n" "${SITE_ENV:-}" | sed 's/\r$//' > .app-env
            : > .env

            # --- DB stack (Postgres + PgBouncer) ---
            DB_DIR="/opt/services/postgres"
            mkdir -p "$DB_DIR"
            awk -F= '/^POSTGRES_PASSWORD=/{print "POSTGRES_PASSWORD="$2}' .app-env > "${DB_DIR}/.env"
            if [ -s "${DB_DIR}/.env" ]; then set -a; . "${DB_DIR}/.env"; set +a; fi

            cat > "${DB_DIR}/docker-compose.yml" <<'DBYAML'
            services:
              postgres:
                image: postgres:15
                restart: always
                env_file: .env
                environment:
                  POSTGRES_USER: admin
                  POSTGRES_DB: drcode
                  POSTGRES_INITDB_ARGS: "--auth=scram-sha-256"
                volumes:
                  - pg_data:/var/lib/postgresql/data
                healthcheck:
                  test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB"]
                  interval: 10s
                  timeout: 5s
                  retries: 10
                networks: [core_db_net]

              pgbouncer:
                image: edoburu/pgbouncer
                restart: always
                env_file: .env
                environment:
                  DB_USER: admin
                  DB_PASSWORD: ${POSTGRES_PASSWORD:-change_me_now}
                  DB_HOST: postgres
                  DB_NAME: drcode
                  AUTH_TYPE: plain
                  POOL_MODE: transaction
                  MAX_CLIENT_CONN: 200
                  DEFAULT_POOL_SIZE: 20
                depends_on:
                  postgres:
                    condition: service_healthy
                networks: [core_db_net]

            volumes:
              pg_data:

            networks:
              core_db_net:
                external: true
                name: core_db_net
            DBYAML
            (cd "${DB_DIR}" && docker compose up -d)

            # keep admin role in sync with current password (best effort)
            if [ -n "${POSTGRES_PASSWORD:-}" ]; then
              docker compose -f "${DB_DIR}/docker-compose.yml" exec -T postgres \
                sh -lc "PGPASSWORD='${POSTGRES_PASSWORD}' psql -U admin -d postgres -v ON_ERROR_STOP=1 \
                  -c \"ALTER ROLE admin WITH PASSWORD '${POSTGRES_PASSWORD}';\"" || true
            fi

            # --- App stack behind Traefik (HTTPS + HTTP→HTTPS redirect) ---
            WWW_DOMAIN="www.${DOMAIN}"
            cat > docker-compose.yml <<YAML
            services:
              app:
                image: ${IMAGE_REF}
                restart: unless-stopped
                env_file: .app-env
                labels:
                  - traefik.enable=true
                  - traefik.docker.network=proxy

                  # Main site (HTTPS)
                  - traefik.http.routers.${SLUG}.rule=Host(\`${DOMAIN}\`) || Host(\`${WWW_DOMAIN}\`)
                  - traefik.http.routers.${SLUG}.entrypoints=websecure
                  - traefik.http.routers.${SLUG}.tls.certresolver=le
                  - traefik.http.routers.${SLUG}.service=${SLUG}
                  - traefik.http.services.${SLUG}.loadbalancer.server.port=${PORT}

                  # Main site (HTTP -> HTTPS)
                  - traefik.http.routers.${SLUG}-http.rule=Host(\`${DOMAIN}\`) || Host(\`${WWW_DOMAIN}\`)
                  - traefik.http.routers.${SLUG}-http.entrypoints=web
                  - traefik.http.routers.${SLUG}-http.middlewares=${SLUG}-redir
                  - traefik.http.routers.${SLUG}-http.service=${SLUG}
                  - traefik.http.middlewares.${SLUG}-redir.redirectscheme.scheme=https
                networks:
                  - proxy
                  - core_db_net
            networks:
              proxy:
                external: true
                name: proxy
              core_db_net:
                external: true
                name: core_db_net
            YAML

            # Optional admin host (HTTPS + HTTP redirect)
            if [ -n "${ADMIN_DOMAIN:-}" ]; then
              awk -v s="${SLUG}" -v d="${ADMIN_DOMAIN}" '
                /- traefik\.http\.services\..*loadbalancer\.server\.port=/ {
                  print;
                  print "                  - traefik.http.routers." s "-admin.rule=Host(`" d "`)";
                  print "                  - traefik.http.routers." s "-admin.entrypoints=websecure";
                  print "                  - traefik.http.routers." s "-admin.tls.certresolver=le";
                  print "                  - traefik.http.routers." s "-admin.service=" s;
                  print "                  - traefik.http.routers." s "-admin-http.rule=Host(`" d "`)";
                  print "                  - traefik.http.routers." s "-admin-http.entrypoints=web";
                  print "                  - traefik.http.routers." s "-admin-http.middlewares=" s "-redir";
                  print "                  - traefik.http.routers." s "-admin-http.service=" s;
                  next
                }
                {print}
              ' docker-compose.yml > docker-compose.tmp && mv docker-compose.tmp docker-compose.yml
            fi

            docker compose pull || true
            docker compose up -d --remove-orphans

            # Prisma migrations (best-effort)
            docker compose exec -T app sh -lc "npx prisma migrate deploy || true"

            # Quick routing sanity (HTTP should 301/307)
            curl -sS -I -H "Host: ${DOMAIN}"         http://127.0.0.1 || true
            curl -sS -I -H "Host: ${WWW_DOMAIN}"      http://127.0.0.1 || true
            [ -n "${ADMIN_DOMAIN:-}" ] && curl -sS -I -H "Host: ${ADMIN_DOMAIN}" http://127.0.0.1 || true

      - name: In-container health check (no DNS needed)
        if: steps.p.outputs.branch == 'main-hetz'
        uses: appleboy/ssh-action@v1
        env:
          SLUG: ${{ steps.cfg.outputs.SLUG }}
          DOMAIN: ${{ steps.cfg.outputs.DOMAIN_PROD }}
        with:
          host: ${{ secrets.HZ_HOST }}
          username: ${{ secrets.HZ_USER || 'root' }}
          key: ${{ secrets.HZ_SSH_KEY }}
          port: 22
          timeout: 60s
          command_timeout: 10m
          envs: SLUG,DOMAIN
        # note: steps run in-order; concurrent dispatches are serialized by the concurrency.group above
          script: |
            set -e
            cd "/opt/sites/${SLUG}"
            PORT="$(docker compose exec -T app sh -lc 'printf "%s" "${PORT:-3000}"')"
            echo "Detected app PORT=$PORT"

            ok=0
            for path in /api/healthz /api/healthz/ /app/api/healthz /app/api/healthz/; do
              echo "Probing http://127.0.0.1:${PORT}${path}"
              for i in 1 2 3 4 5 6 7 8 9 10; do
                if docker compose exec -T app node -e "const http=require('http');http.get({host:'127.0.0.1',port:${PORT},path:'${path}',headers:{'x-forwarded-proto':'https','host':'${DOMAIN:-localhost}'}},r=>process.exit(r.statusCode<400?0:1)).on('error',()=>process.exit(1))"; then
                  echo "✅ ${path} OK"; ok=1; break
                fi
                echo "retry $i"; sleep 3
              done
              [ "$ok" -eq 1 ] && break
            done

            if [ "$ok" -ne 1 ]; then
              echo "❌ Health failed. Recent app logs:"
              docker compose logs --no-color --tail=200 app || true
              exit 1
            fi

            echo "✅ App healthy inside container"

      - name: Public health check (through Traefik/Cloudflare)
        if: steps.p.outputs.branch == 'main-hetz'
        run: |
          set -e
          dom="${{ steps.cfg.outputs.DOMAIN_PROD }}"
          adm="${{ steps.cfg.outputs.DOMAIN_ADMIN }}"
          [ -n "$dom" ] || { echo "❌ DOMAIN_PROD not set in .cicd-config.yml"; exit 1; }

          ok=0
          try_domain () {
            host="$1"
            for path in /api/healthz /api/healthz/ /; do
              for i in {1..24}; do
                code=$(curl -k -sS -o /tmp/body.$$ -w "%{http_code}" "https://${host}${path}")
                if [[ "$code" =~ ^(200|204|301|302|307|308)$ ]]; then
                  echo "✅ Public ${host}${path} OK ($code)"; ok=1; return 0
                fi
                echo "retry $i (got $code on ${host}${path})"; sleep 5
              done
            done
            return 1
          }

          try_domain "$dom" || true
          if [ $ok -ne 1 ] && [ -n "$adm" ]; then
            try_domain "$adm" || true
          fi

          if [ $ok -ne 1 ]; then
            echo "---- Body sample ----"
            head -c 400 /tmp/body.$$ || true
            echo
            echo "❌ Public healthcheck failed"
            exit 1
          fi
