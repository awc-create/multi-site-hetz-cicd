name: Manual Hetzner Deploy

on:
  workflow_dispatch:
    inputs:
      repository:
        description: "owner/repo of the site"
        required: true
        default: awc-create/drcodezenna
      branch:
        description: "Branch to deploy"
        required: true
        default: main-hetz

permissions:
  contents: read
  actions: read
  packages: write

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Read inputs
        id: inp
        run: |
          echo "repository=${{ github.event.inputs.repository }}" >> $GITHUB_OUTPUT
          echo "branch=${{ github.event.inputs.branch }}" >> $GITHUB_OUTPUT

      - name: Checkout target website repo
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.inp.outputs.repository }}
          ref: ${{ steps.inp.outputs.branch }}
          path: site

      - name: Read .cicd-config.yml (slug/port/domains)
        id: cfg
        shell: bash
        run: |
          cd site
          SLUG="site"
          PORT="3000"
          DOMAIN_PROD=""
          DOMAIN_ADMIN=""
          if [ -f ".cicd-config.yml" ]; then
            get(){ grep -E "^$1:" .cicd-config.yml | head -1 | awk -F': *' '{print $2}' | tr -d "\"'"; }
            SLUG=$(get slug || echo "$SLUG")
            PORT=$(get port || echo "$PORT")
            DOM_BLOCK="$(awk '/^domains:/{f=1;next} f && /^[^ ]/{f=0} f{print}' .cicd-config.yml)"
            DOMAIN_PROD="$(printf '%s\n' "$DOM_BLOCK" | awk '/prod:/{print $2}' | tr -d "\"'")"
            DOMAIN_ADMIN="$(printf '%s\n' "$DOM_BLOCK" | awk '/admin:/{print $2}' | tr -d "\"'")"
          fi
          echo "SLUG=$SLUG" >> $GITHUB_OUTPUT
          echo "PORT=$PORT" >> $GITHUB_OUTPUT
          echo "DOMAIN_PROD=$DOMAIN_PROD" >> $GITHUB_OUTPUT
          echo "DOMAIN_ADMIN=$DOMAIN_ADMIN" >> $GITHUB_OUTPUT

      - name: Derive image coordinates
        id: meta
        run: |
          OWNER_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(basename "${{ steps.inp.outputs.repository }}")
          IMAGE="ghcr.io/${OWNER_LOWER}/${REPO_NAME}"
          SHORT="${GITHUB_SHA::7}"
          echo "image=$IMAGE"     >> $GITHUB_OUTPUT
          echo "ref=$IMAGE:$SHORT" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR (push)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build & push site image
        uses: docker/build-push-action@v6
        with:
          context: site
          push: true
          tags: |
            ${{ steps.meta.outputs.ref }}
            ${{ steps.meta.outputs.image }}:latest

      - name: Compute SITE_ENV secret key (multiline .env)
        id: k
        run: |
          REPO_NAME=$(basename "${{ steps.inp.outputs.repository }}")
          KEY=$(echo "$REPO_NAME" | tr '[:lower:]-' '[:upper:]_')
          echo "SITE_ENV_KEY=SITE_ENV__${KEY}" >> $GITHUB_OUTPUT

      - name: Deploy over SSH (DB up, write .env, Traefik labels, run app)
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.HZ_HOST }}
          username: ${{ secrets.HZ_USER || 'root' }}
          key: ${{ secrets.HZ_SSH_KEY }}
          port: 22
          timeout: 60s
          command_timeout: 15m

          # üëà IMPORTANT: pass env vars to the remote. This fixes "SLUG: unbound variable".
          envs: |
            SLUG=${{ steps.cfg.outputs.SLUG }},
            PORT=${{ steps.cfg.outputs.PORT }},
            DOMAIN=${{ steps.cfg.outputs.DOMAIN_PROD }},
            ADMIN_DOMAIN=${{ steps.cfg.outputs.DOMAIN_ADMIN }},
            IMAGE_REF=${{ steps.meta.outputs.ref }},
            SITE_ENV=${{ secrets[steps.k.outputs.SITE_ENV_KEY] }},
            GHCR_USER=${{ github.repository_owner }},
            GHCR_TOKEN=${{ secrets.GHCR_READ_TOKEN || secrets.GITHUB_TOKEN }}

          script: |
            set -eo pipefail
            : "${SLUG:?missing SLUG}"
            : "${PORT:?missing PORT}"
            : "${DOMAIN:?missing DOMAIN}"
            : "${IMAGE_REF:?missing IMAGE_REF}"

            # Create Traefik network if missing; let Compose create core_db_net (avoid label mismatch)
            docker network create proxy >/dev/null 2>&1 || true

            # --- Site dir & .env ---
            SITE_DIR="/opt/sites/${SLUG}"
            mkdir -p "$SITE_DIR"
            cd "$SITE_DIR"
            printf "%s\n" "${SITE_ENV:-}" | sed 's/\r$//' > .env

            # --- Sync DB password into global DB stack .env ---
            DB_DIR="/opt/services/postgres"
            mkdir -p "$DB_DIR"
            if grep -q '^POSTGRES_PASSWORD=' .env; then
              awk -F= '/^POSTGRES_PASSWORD=/{print "POSTGRES_PASSWORD="$2}' .env > "${DB_DIR}/.env"
            fi

            # --- DB stack (creates core_db_net with correct labels) ---
            cat > "${DB_DIR}/docker-compose.yml" <<'DBYAML'
            services:
              postgres:
                image: postgres:15
                restart: always
                environment:
                  POSTGRES_USER: admin
                  POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-change_me_now}
                  POSTGRES_DB: drcode
                  POSTGRES_INITDB_ARGS: "--auth=scram-sha-256"
                volumes:
                  - pg_data:/var/lib/postgresql/data
                healthcheck:
                  test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB"]
                  interval: 10s
                  timeout: 5s
                  retries: 10
                networks: [core_db_net]
              pgbouncer:
                image: edoburu/pgbouncer
                restart: always
                environment:
                  DB_USER: admin
                  DB_PASSWORD: ${POSTGRES_PASSWORD:-change_me_now}
                  DB_HOST: postgres
                  DB_NAME: drcode
                  POOL_MODE: transaction
                  MAX_CLIENT_CONN: 200
                  DEFAULT_POOL_SIZE: 20
                depends_on:
                  postgres:
                    condition: service_healthy
                networks: [core_db_net]
            volumes:
              pg_data:
            networks:
              core_db_net:
                name: core_db_net
            DBYAML

            cd "$DB_DIR"
            docker compose up -d

            # --- App stack ---
            cd "$SITE_DIR"
            cat > docker-compose.yml <<YAML
            services:
              app:
                image: ${IMAGE_REF}
                restart: unless-stopped
                env_file: .env
                labels:
                  - traefik.enable=true
                  - traefik.http.routers.${SLUG}.rule=Host(\`${DOMAIN}\`)
                  - traefik.http.routers.${SLUG}.entrypoints=websecure
                  - traefik.http.routers.${SLUG}.tls.certresolver=le
                  - traefik.http.services.${SLUG}.loadbalancer.server.port=${PORT}
                networks:
                  - proxy
                  - core_db_net
            networks:
              proxy:
                external: true
              core_db_net:
                external: true
            YAML

            # Optional second router for admin subdomain
            if [ -n "${ADMIN_DOMAIN:-}" ]; then
              awk -v s="${SLUG}" -v d="${ADMIN_DOMAIN}" '
                /- traefik\.http\.services\..*loadbalancer\.server\.port/ {
                  print;
                  print "                  - traefik.http.routers." s "-admin.rule=Host(`" d "`)";
                  print "                  - traefik.http.routers." s "-admin.entrypoints=websecure";
                  print "                  - traefik.http.routers." s "-admin.tls.certresolver=le";
                  print "                  - traefik.http.routers." s "-admin.service=" s;
                  next
                }
                {print}
              ' docker-compose.yml > docker-compose.tmp && mv docker-compose.tmp docker-compose.yml
            fi

            docker compose pull || true
            docker compose up -d --remove-orphans
            docker compose exec -T app sh -lc "npx prisma migrate deploy || true"

      - name: Health check
        run: |
          u="https://${{ steps.cfg.outputs.DOMAIN_PROD }}/api/healthz"
          echo "Waiting on: $u"
          for i in {1..24}; do
            if curl -fsSL "$u" >/dev/null; then echo "‚úÖ OK"; exit 0; fi
            echo "retry $i"; sleep 5
          done
          echo "‚ùå Healthcheck failed"; exit 1
