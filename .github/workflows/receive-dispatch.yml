name: Receive & Deploy to Hetzner

on:
  repository_dispatch:
    types: [ deploy ]

permissions:
  contents: read
  packages: write
  actions: read

concurrency:
  group: hetz-${{ github.event.client_payload.repository_name }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Extract payload
        id: p
        run: |
          echo "repository=${{ github.event.client_payload.repository }}" >> $GITHUB_OUTPUT
          echo "repository_name=${{ github.event.client_payload.repository_name }}" >> $GITHUB_OUTPUT
          echo "branch=${{ github.event.client_payload.branch }}" >> $GITHUB_OUTPUT

      - name: Checkout target website repo
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.p.outputs.repository }}
          ref: ${{ steps.p.outputs.branch }}
          path: site

      - name: Read .cicd-config.yml (slug / port / domains.prod / domains.admin)
        id: cfg
        shell: bash
        run: |
          cd site
          SLUG="site"
          PORT="3000"
          DOMAIN_PROD=""
          DOMAIN_ADMIN=""
          if [ -f ".cicd-config.yml" ]; then
            get_val(){ grep -E "^$1:" .cicd-config.yml | head -1 | awk -F': *' '{print $2}' | tr -d "\"'"; }
            SLUG=$(get_val slug || echo "$SLUG")
            PORT=$(get_val port || echo "$PORT")
            DOM_BLOCK="$(awk '/^domains:/{f=1;next} f && /^[^ ]/{f=0} f{print}' .cicd-config.yml)"
            DOMAIN_PROD="$(printf '%s\n' "$DOM_BLOCK" | awk '/prod:/{print $2}' | tr -d "\"'")"
            DOMAIN_ADMIN="$(printf '%s\n' "$DOM_BLOCK" | awk '/admin:/{print $2}' | tr -d "\"'")"
          fi
          echo "SLUG=$SLUG" >> $GITHUB_OUTPUT
          echo "PORT=$PORT" >> $GITHUB_OUTPUT
          echo "DOMAIN_PROD=$DOMAIN_PROD" >> $GITHUB_OUTPUT
          echo "DOMAIN_ADMIN=$DOMAIN_ADMIN" >> $GITHUB_OUTPUT

      - name: Gate – only handle prod (main-hetz) deploys
        if: steps.p.outputs.branch != 'main-hetz'
        run: |
          echo "ℹ️ Branch '${{ steps.p.outputs.branch }}' is not main-hetz. Skipping."
          exit 0

      - name: Guard required secrets
        run: |
          test -n "${{ secrets.HZ_HOST }}"            || { echo "❌ Missing secret: HZ_HOST"; exit 1; }
          test -n "${{ secrets.HZ_SSH_KEY }}"         || { echo "❌ Missing secret: HZ_SSH_KEY"; exit 1; }
          test -n "${{ secrets.TRAEFIK_ACME_EMAIL }}" || { echo "❌ Missing secret: TRAEFIK_ACME_EMAIL"; exit 1; }
          test -n "${{ secrets.CF_API_TOKEN }}"       || { echo "❌ Missing secret: CF_API_TOKEN"; exit 1; }

      - name: Derive image coordinates
        id: meta
        shell: bash
        run: |
          OWNER_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME="${{ steps.p.outputs.repository_name }}"
          IMAGE="ghcr.io/${OWNER_LOWER}/${REPO_NAME}"
          SHORT="${GITHUB_SHA::7}"
          echo "image=$IMAGE"      >> $GITHUB_OUTPUT
          echo "ref=$IMAGE:$SHORT" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR (push)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build & push site image
        uses: docker/build-push-action@v6
        with:
          context: site
          push: true
          tags: |
            ${{ steps.meta.outputs.ref }}
            ${{ steps.meta.outputs.image }}:latest

      - name: Compute site env secret key (multiline .env)
        id: k
        shell: bash
        run: |
          REPO_NAME="${{ steps.p.outputs.repository_name }}"
          KEY="$(echo "$REPO_NAME" | tr '[:lower:]-' '[:upper:]_')"  # drcodezenna -> DRCODEZENNA
          echo "SITE_ENV_KEY=SITE_ENV__${KEY}" >> $GITHUB_OUTPUT
          echo "Resolved env secret key: SITE_ENV__${KEY}"

      - name: Deploy over SSH (Traefik + DB + app; HTTPS + redirect; local API)
        uses: appleboy/ssh-action@v1
        env:
          SLUG:         ${{ steps.cfg.outputs.SLUG }}
          PORT:         ${{ steps.cfg.outputs.PORT }}
          DOMAIN:       ${{ steps.cfg.outputs.DOMAIN_PROD }}
          ADMIN_DOMAIN: ${{ steps.cfg.outputs.DOMAIN_ADMIN }}
          IMAGE_REF:    ${{ steps.meta.outputs.ref }}
          SITE_ENV:     ${{ secrets[steps.k.outputs.SITE_ENV_KEY] }}
          GHCR_USER:    ${{ github.repository_owner }}
          GHCR_TOKEN:   ${{ secrets.GHCR_READ_TOKEN || secrets.GITHUB_TOKEN }}
          ACME_EMAIL:   ${{ secrets.TRAEFIK_ACME_EMAIL }}
          CF_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
        with:
          host: ${{ secrets.HZ_HOST }}
          username: ${{ secrets.HZ_USER || 'root' }}
          key: ${{ secrets.HZ_SSH_KEY }}
          port: 22
          timeout: 60s
          command_timeout: 20m
          envs: SLUG,PORT,DOMAIN,ADMIN_DOMAIN,IMAGE_REF,SITE_ENV,GHCR_USER,GHCR_TOKEN,ACME_EMAIL,CF_API_TOKEN
          script: |
            set -e

            case "${ACME_EMAIL}" in ""|*example.com*) echo "❌ TRAEFIK_ACME_EMAIL must be a real email"; exit 1;; esac
            [ -n "${SLUG:-}" ] && [ -n "${DOMAIN:-}" ] && [ -n "${IMAGE_REF:-}" ] || { echo "❌ Missing SLUG/DOMAIN/IMAGE_REF"; exit 1; }

            echo "Deploying ${SLUG} → https://${DOMAIN} (image: ${IMAGE_REF})"

            docker network create proxy >/dev/null 2>&1 || true
            docker network create core_db_net >/dev/null 2>&1 || true

            # Traefik (with local dashboard/API for CI polling)
            TDIR="/opt/services/traefik"
            mkdir -p "$TDIR/letsencrypt"
            [ -f "$TDIR/letsencrypt/acme.json" ] || install -m 600 /dev/null "$TDIR/letsencrypt/acme.json"
            cat > "$TDIR/.env" <<EOF
            ACME_EMAIL=${ACME_EMAIL}
            CLOUDFLARE_DNS_API_TOKEN=${CF_API_TOKEN}
            CF_DNS_API_TOKEN=${CF_API_TOKEN}
            EOF
            cat > "$TDIR/docker-compose.yml" <<'YAML'
            services:
              traefik:
                image: traefik:v3.0
                restart: unless-stopped
                env_file: .env
                command:
                  - --providers.docker=true
                  - --providers.docker.exposedbydefault=false
                  - --entrypoints.web.address=:80
                  - --entrypoints.websecure.address=:443
                  - --certificatesresolvers.le.acme.dnschallenge=true
                  - --certificatesresolvers.le.acme.dnschallenge.provider=cloudflare
                  - --certificatesresolvers.le.acme.email=${ACME_EMAIL}
                  - --certificatesresolvers.le.acme.storage=/letsencrypt/acme.json
                  - --api.dashboard=true
                  - --api.insecure=true
                ports:
                  - 80:80
                  - 443:443
                  - 127.0.0.1:8080:8080
                volumes:
                  - /var/run/docker.sock:/var/run/docker.sock:ro
                  - ./letsencrypt:/letsencrypt
                networks: [proxy]
            networks:
              proxy:
                external: true
                name: proxy
            YAML
            (cd "$TDIR" && docker compose up -d)

            if [ -n "${GHCR_TOKEN:-}" ]; then
              echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USER" --password-stdin
            fi

            SITE_DIR="/opt/sites/${SLUG}"
            mkdir -p "$SITE_DIR"
            cd "$SITE_DIR"
            printf "%s\n" "${SITE_ENV:-}" | sed 's/\r$//' > .app-env

            # DB stack
            DB_DIR="/opt/services/postgres"
            mkdir -p "$DB_DIR"
            awk -F= '/^POSTGRES_PASSWORD=/{print "POSTGRES_PASSWORD="$2}' .app-env > "${DB_DIR}/.env"
            cat > "${DB_DIR}/docker-compose.yml" <<'DBYAML'
            services:
              postgres:
                image: postgres:15
                restart: always
                env_file: .env
                environment:
                  POSTGRES_USER: admin
                  POSTGRES_DB: drcode
                  POSTGRES_INITDB_ARGS: "--auth=scram-sha-256"
                volumes:
                  - pg_data:/var/lib/postgresql/data
                healthcheck:
                  test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB"]
                  interval: 10s
                  timeout: 5s
                  retries: 10
                networks: [core_db_net]
              pgbouncer:
                image: edoburu/pgbouncer
                restart: always
                env_file: .env
                environment:
                  DB_USER: admin
                  DB_PASSWORD: ${POSTGRES_PASSWORD:-change_me_now}
                  DB_HOST: postgres
                  DB_NAME: drcode
                  POOL_MODE: transaction
                  MAX_CLIENT_CONN: 200
                  DEFAULT_POOL_SIZE: 20
                  AUTH_TYPE: plain
                depends_on:
                  postgres:
                    condition: service_healthy
                networks: [core_db_net]
            volumes:
              pg_data:
            networks:
              core_db_net:
                external: true
                name: core_db_net
            DBYAML
            (cd "${DB_DIR}" && docker compose up -d)

            # App stack (HTTPS + HTTP→HTTPS redirect)
            WWW_DOMAIN="www.${DOMAIN}"
            cat > docker-compose.yml <<YAML
            services:
              app:
                image: ${IMAGE_REF}
                restart: unless-stopped
                env_file: .app-env
                labels:
                  - traefik.enable=true
                  - traefik.docker.network=proxy
                  - traefik.http.routers.${SLUG}.rule=Host(\`${DOMAIN}\`) || Host(\`${WWW_DOMAIN}\`)
                  - traefik.http.routers.${SLUG}.entrypoints=websecure
                  - traefik.http.routers.${SLUG}.tls.certresolver=le
                  - traefik.http.routers.${SLUG}.service=${SLUG}
                  - traefik.http.services.${SLUG}.loadbalancer.server.port=${PORT}
                  - traefik.http.routers.${SLUG}-http.rule=Host(\`${DOMAIN}\`) || Host(\`${WWW_DOMAIN}\`)
                  - traefik.http.routers.${SLUG}-http.entrypoints=web
                  - traefik.http.routers.${SLUG}-http.middlewares=${SLUG}-redirect
                  - traefik.http.routers.${SLUG}-http.service=${SLUG}
                  - traefik.http.middlewares.${SLUG}-redirect.redirectscheme.scheme=https
                networks: [proxy, core_db_net]
            networks:
              proxy:      { external: true, name: proxy }
              core_db_net:{ external: true, name: core_db_net }
            YAML

            # Optional dedicated admin host — HTTPS only + HTTP→HTTPS
            if [ -n "${ADMIN_DOMAIN:-}" ]; then
              awk -v s="${SLUG}" -v d="${ADMIN_DOMAIN}" '
                /- traefik\.http\.services\..*loadbalancer\.server\.port=/ {
                  print; 
                  print "                  - traefik.http.routers." s "-admin.rule=Host(`" d "`)";
                  print "                  - traefik.http.routers." s "-admin.entrypoints=websecure";
                  print "                  - traefik.http.routers." s "-admin.tls.certresolver=le";
                  print "                  - traefik.http.routers." s "-admin.service=" s;
                  print "                  - traefik.http.routers." s "-admin-http.rule=Host(`" d "`)";
                  print "                  - traefik.http.routers." s "-admin-http.entrypoints=web";
                  print "                  - traefik.http.routers." s "-admin-http.middlewares=" s "-redirect";
                  print "                  - traefik.http.routers." s "-admin-http.service=" s;
                  next
                } {print}
              ' docker-compose.yml > docker-compose.tmp && mv docker-compose.tmp docker-compose.yml
            fi

            docker compose pull || true
            docker compose up -d --remove-orphans

            # Prisma migrations (best-effort)
            docker compose exec -T app sh -lc "npx prisma migrate deploy || true"

      - name: Wait for Traefik routers (HTTPS)
        uses: appleboy/ssh-action@v1
        env:
          DOMAIN:       ${{ steps.cfg.outputs.DOMAIN_PROD }}
          ADMIN_DOMAIN: ${{ steps.cfg.outputs.DOMAIN_ADMIN }}
        with:
          host: ${{ secrets.HZ_HOST }}
          username: ${{ secrets.HZ_USER || 'root' }}
          key: ${{ secrets.HZ_SSH_KEY }}
          port: 22
          timeout: 60s
          command_timeout: 10m
          envs: DOMAIN,ADMIN_DOMAIN
          script: |
            set -euo pipefail
            need_hosts=()
            [ -n "${DOMAIN:-}" ] && need_hosts+=("$DOMAIN" "www.${DOMAIN}")
            [ -n "${ADMIN_DOMAIN:-}" ] && need_hosts+=("${ADMIN_DOMAIN}")
            echo "Waiting for Traefik API..."
            for i in $(seq 1 60); do
              if docker exec traefik-traefik-1 sh -lc 'apk add --no-cache curl >/dev/null 2>&1 || true; curl -sf http://127.0.0.1:8080/api/version >/dev/null'; then
                echo "Traefik API is up"; break
              fi
              echo "  api not ready ($i)"; sleep 2
            done
            wait_host() {
              host="$1"; echo "→ waiting router for $host"
              for i in $(seq 1 60); do
                json="$(docker exec traefik-traefik-1 sh -lc 'curl -sf http://127.0.0.1:8080/api/http/routers' || true)"
                if printf '%s' "$json" | grep -F "Host(\`$host\`)" >/dev/null \
                   && printf '%s' "$json" | grep -F '"entryPoints":["websecure"]' >/dev/null \
                   && printf '%s' "$json" | grep -F '"status":"enabled"' >/dev/null; then
                  echo "✅ router ready for $host"; return 0
                fi
                sleep 3
              done
              echo "❌ timeout waiting for router $host"; printf '%s\n' "$json" | head -c 2000 || true; exit 1
            }
            for h in "${need_hosts[@]}"; do wait_host "$h"; done

      - name: In-container health check (no DNS needed)
        uses: appleboy/ssh-action@v1
        env:
          SLUG: ${{ steps.cfg.outputs.SLUG }}
          DOMAIN: ${{ steps.cfg.outputs.DOMAIN_PROD }}
        with:
          host: ${{ secrets.HZ_HOST }}
          username: ${{ secrets.HZ_USER || 'root' }}
          key: ${{ secrets.HZ_SSH_KEY }}
          port: 22
          timeout: 60s
          command_timeout: 10m
          envs: SLUG,DOMAIN
          script: |
            set -e
            cd "/opt/sites/${SLUG}"
            PORT="$(docker compose exec -T app sh -lc 'printf "%s" "${PORT:-3000}"')"
            echo "Detected app PORT=$PORT"
            ok=0
            for path in /api/healthz /api/healthz/ /app/api/healthz /app/api/healthz/; do
              echo "Probing http://127.0.0.1:${PORT}${path}"
              for i in {1..20}; do
                if docker compose exec -T app node -e "const http=require('http');http.get({host:'127.0.0.1',port:${PORT},path:'${path}',headers:{'x-forwarded-proto':'https','host':'${DOMAIN:-localhost}'}},r=>process.exit(r.statusCode<400?0:1)).on('error',()=>process.exit(1))"; then
                  echo "✅ ${path} OK"; ok=1; break; fi
                echo "retry $i"; sleep 3
              done
              [ "$ok" -eq 1 ] && break
            done
            [ "$ok" -eq 1 ] || { echo "❌ Internal health failed"; docker compose logs --no-color --tail=200 app || true; exit 1; }
            echo "✅ App healthy inside container"

      - name: Public health check (through Traefik/Cloudflare)
        env:
          DOMAIN: ${{ steps.cfg.outputs.DOMAIN_PROD }}
        run: |
          set -e
          urls=("https://${DOMAIN}/api/healthz" "https://${DOMAIN}/api/healthz/")
          ok=0
          for i in {1..48}; do
            for u in "${urls[@]}"; do
              code=$(curl -k -L -sS -D >(tee /dev/stderr) -o /tmp/health_body -w "%{http_code}" "$u" || true)
              echo "GET $u -> HTTP $code"
              if [[ "$code" =~ ^(200|204|301|302|307|308)$ ]]; then
                echo "✅ Public health OK ($code) at $u"; ok=1; break
              fi
              if grep -q "404 page not found" /tmp/health_body 2>/dev/null; then
                echo "Traefik 404 (router warming or path) — retrying…"
              else
                echo "Body (first 200 bytes):"; head -c 200 /tmp/health_body || true; echo
              fi
            done
            [ $ok -eq 1 ] && break
            sleep 5
          done
          [ $ok -eq 1 ] || { echo "❌ Public health failed"; exit 1; }

      - name: Diagnostics (only on failure)
        if: failure()
        uses: appleboy/ssh-action@v1
        env:
          SLUG:   ${{ steps.cfg.outputs.SLUG }}
          DOMAIN: ${{ steps.cfg.outputs.DOMAIN_PROD }}
        with:
          host: ${{ secrets.HZ_HOST }}
          username: ${{ secrets.HZ_USER || 'root' }}
          key: ${{ secrets.HZ_SSH_KEY }}
          port: 22
          timeout: 60s
          command_timeout: 15m
          envs: SLUG,DOMAIN
          script: |
            set -euo pipefail
            echo "== Traefik recent logs =="; docker logs --since=5m traefik-traefik-1 | tail -n 300 || true
            echo; echo "== Routers (API) =="; docker exec traefik-traefik-1 sh -lc 'apk add --no-cache curl jq >/dev/null 2>&1 || true; curl -sf http://127.0.0.1:8080/api/http/routers | jq "[ .[] | {name,rule,entryPoints,status} ]"' || true
            echo; echo "== Services (API) =="; docker exec traefik-traefik-1 sh -lc 'curl -sf http://127.0.0.1:8080/api/http/services | jq "[ .[] | {name,type,usedBy} ]"' || true
            echo; echo "== App logs (last 200) =="; cd /opt/sites/${SLUG}; docker compose logs --no-color --tail=200 app || true
